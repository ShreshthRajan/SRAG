{
  "phase": "phase1_star_calibration",
  "status": "completed",
  "start_time": "2025-11-25T18:02:48.217791",
  "stages": {
    "initialization": {
      "status": "completed",
      "duration": 38.28044319152832
    },
    "dataset_preparation": {
      "status": "completed",
      "duration": 8.92772889137268,
      "train_problems": 160,
      "val_problems": 40
    },
    "solution_generation": {
      "status": "completed",
      "duration": 5930.565181970596,
      "train_solutions": 936,
      "val_solutions": 237
    },
    "calibration_training": {
      "status": "completed",
      "duration": 0.6552631855010986,
      "training_metrics": {
        "ece": 0.007627362825519079,
        "mce": 0.09689704365200447,
        "brier_score": 0.12952193957939956,
        "temperature": 1.073455810546875,
        "num_samples": 936,
        "reliability_data": {
          "bin_boundaries": [
            0.0,
            0.06666666666666667,
            0.13333333333333333,
            0.2,
            0.26666666666666666,
            0.3333333333333333,
            0.4,
            0.4666666666666667,
            0.5333333333333333,
            0.6,
            0.6666666666666666,
            0.7333333333333333,
            0.8,
            0.8666666666666667,
            0.9333333333333333,
            1.0
          ],
          "bin_accuracies": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.6385114119721964,
            0.7686111111111109,
            0.0,
            0.0,
            0.0,
            0.0
          ],
          "bin_confidences": [
            0.03333333333333333,
            0.1,
            0.16666666666666669,
            0.23333333333333334,
            0.3,
            0.3666666666666667,
            0.43333333333333335,
            0.5,
            0.5666666666666667,
            0.644388388899157,
            0.6717140674591064,
            0.7666666666666666,
            0.8333333333333334,
            0.9,
            0.9666666666666667
          ],
          "bin_counts": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            918,
            18,
            0,
            0,
            0,
            0
          ]
        }
      }
    },
    "calibration_validation": {
      "status": "completed",
      "duration": 0.07179117202758789,
      "calibration_metrics": {
        "ece": 0.003946176851708456,
        "mce": 0.09401316881179822,
        "brier_score": 0.1255243112238002,
        "temperature": 1.073455810546875,
        "num_samples": 237,
        "reliability_data": {
          "bin_boundaries": [
            0.0,
            0.06666666666666667,
            0.13333333333333333,
            0.2,
            0.26666666666666666,
            0.3333333333333333,
            0.4,
            0.4666666666666667,
            0.5333333333333333,
            0.6,
            0.6666666666666666,
            0.7333333333333333,
            0.8,
            0.8666666666666667,
            0.9333333333333333,
            1.0
          ],
          "bin_accuracies": [
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.6429809932556713,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0
          ],
          "bin_confidences": [
            0.03333333333333333,
            0.1,
            0.16666666666666669,
            0.23333333333333334,
            0.3,
            0.3666666666666667,
            0.43333333333333335,
            0.5,
            0.5666666666666667,
            0.6453809556531293,
            0.7,
            0.7666666666666666,
            0.8333333333333334,
            0.9,
            0.9666666666666667
          ],
          "bin_counts": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            233,
            4,
            0,
            0,
            0,
            0
          ]
        },
        "quality_status": "excellent",
        "target_achieved": "True"
      }
    }
  },
  "total_duration": 5978.500986337662,
  "end_time": "2025-11-25T19:42:26.718985",
  "final_ece": 0.003946176851708456,
  "target_achieved": "True",
  "quality_status": "excellent",
  "calibrator_path": "checkpoints/phase1_star_calibrator_1764099746.pt"
}    "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.678,
    "true_score": 0.678,
    "generation_temperature": 0.5,
    "solution_length": 22,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v6",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if start not in graph:\n        raise ValueError(\"Start node is not in the graph\")\n    \n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    visited = set()\n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n        \n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited:\n                new_distance = distances[current_node] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v6",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.678,
    "true_score": 0.678,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v6",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if not graph or start not in graph:\n        return {}\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n\n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n\n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited:\n                new_distance = distances[current_node] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n\n    return distances",
    "problem": {
      "problem_id": "hard_001_v6",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.668,
    "true_score": 0.668,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v6",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if not graph or start not in graph:\n        return {}\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n\n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n\n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited:\n                new_distance = distances[current_node] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n\n    return distances",
    "problem": {
      "problem_id": "hard_001_v6",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.668,
    "true_score": 0.668,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v6",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if not graph or start not in graph:\n        return {}\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n\n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n\n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited:\n                new_distance = distances[current_node] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n\n    return distances",
    "problem": {
      "problem_id": "hard_001_v6",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.668,
    "true_score": 0.668,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v7",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n    \n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n        \n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited and distances[neighbor] > distances[current_node] + weight:\n                distances[neighbor] = distances[current_node] + weight\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v7",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.678,
    "true_score": 0.678,
    "generation_temperature": 0.5,
    "solution_length": 16,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v7",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if not graph or start not in graph:\n        return {}\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n\n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n\n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited:\n                new_distance = distances[current_node] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n\n    return distances",
    "problem": {
      "problem_id": "hard_001_v7",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.668,
    "true_score": 0.668,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v7",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if not graph or start not in graph:\n        return {}\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n\n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n\n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited:\n                new_distance = distances[current_node] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n\n    return distances",
    "problem": {
      "problem_id": "hard_001_v7",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.668,
    "true_score": 0.668,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v7",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if not graph or start not in graph:\n        return {}\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n\n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n\n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited:\n                new_distance = distances[current_node] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n\n    return distances",
    "problem": {
      "problem_id": "hard_001_v7",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.668,
    "true_score": 0.668,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v7",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if start not in graph:\n        raise ValueError(\"Start node not found in the graph\")\n    \n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v7",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.658,
    "true_score": 0.658,
    "generation_temperature": 0.5,
    "solution_length": 25,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v7",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if start not in graph:\n        raise ValueError(\"Start node not in the graph\")\n    \n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v7",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.658,
    "true_score": 0.658,
    "generation_temperature": 0.5,
    "solution_length": 25,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v8",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if not graph or start not in graph:\n        raise ValueError(\"Invalid input\")\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n\n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n\n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited and distances[neighbor] > distances[current_node] + weight:\n                distances[neighbor] = distances[current_node] + weight\n\n    return distances",
    "problem": {
      "problem_id": "hard_001_v8",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6880000000000001,
    "true_score": 0.6880000000000001,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v8",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if not graph or start not in graph:\n        raise ValueError(\"Invalid input\")\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n\n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n\n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited and distances[neighbor] > distances[current_node] + weight:\n                distances[neighbor] = distances[current_node] + weight\n\n    return distances",
    "problem": {
      "problem_id": "hard_001_v8",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6880000000000001,
    "true_score": 0.6880000000000001,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v8",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances dictionary with infinity for all nodes except the start node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store nodes to visit, ordered by their distance from the start\n    import heapq\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        # If the current distance is greater than the known distance to the current node, skip it\n        if current_distance > distances[current_node]:\n            continue\n        \n        # Explore all neighbors of the current node\n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # If a shorter path is found, update the distance and add the neighbor to the priority queue\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v8",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v8",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if not graph or start not in graph:\n        return {}\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n\n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n\n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited:\n                new_distance = distances[current_node] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n\n    return distances",
    "problem": {
      "problem_id": "hard_001_v8",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.668,
    "true_score": 0.668,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v8",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if not graph or start not in graph:\n        return {}\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n\n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n\n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited:\n                new_distance = distances[current_node] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n\n    return distances",
    "problem": {
      "problem_id": "hard_001_v8",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.668,
    "true_score": 0.668,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v8",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    if not graph or start not in graph:\n        return {}\n\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    visited = set()\n\n    while len(visited) < len(graph):\n        current_node = min(distances, key=distances.get)\n        visited.add(current_node)\n\n        for neighbor, weight in graph[current_node]:\n            if neighbor not in visited:\n                new_distance = distances[current_node] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n\n    return distances",
    "problem": {
      "problem_id": "hard_001_v8",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.668,
    "true_score": 0.668,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/129",
    "code": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    if n < 2 or k < 1:\n        raise ValueError(\"Invalid input: grid must be at least 2x2 and k must be at least 1\")\n    \n    # Initialize the minimum path with the first cell\n    min_path = [grid[0][0]]\n    visited = {(grid[0][0]): 0}\n    \n    # Directions for moving up, down, left, right\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # Perform BFS\n    queue = [(min_path[-1], 0)]\n    while queue:\n        current_path, current_index = queue.pop(0)\n        \n        # If we have reached the required length, return the path\n        if len(current_path) == k:\n            return current_path\n        \n        # Explore neighbors\n        for dx, dy in directions:\n            new_x, new_y = current_index[0] + dx, current_index[1] + dy\n            if 0 <= new_x < n and 0 <= new_y < n and (new_x, new_y) not in visited:\n                new_path = current_path + [grid[new_x][new_y]]\n                visited[(new_x, new_y)] = len(new_path)\n                queue.append((new_path, (new_x, new_y)))\n    \n    # If no path is found, return an empty list\n    return []",
    "problem": {
      "problem_id": "HumanEval/129",
      "question": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "solutions": [
        "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"
      ],
      "starter_code": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 12
    },
    "base_score": 0.7090000000000001,
    "true_score": 0.7090000000000001,
    "generation_temperature": 0.5,
    "solution_length": 33,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/129",
    "code": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    if n < 2 or k < 1:\n        return []\n\n    # Initialize the visited set and the result list\n    visited = set()\n    result = []\n\n    # Define the directions for moving up, down, left, right\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Helper function to perform DFS\n    def dfs(x, y, path, steps):\n        if steps == k:\n            result.append(path)\n            return\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n:\n                dfs(nx, ny, path + [grid[nx][ny]], steps + 1)\n        visited.remove((x, y))\n\n    # Start DFS from every cell\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, [grid[i][j]], 1)\n\n    # Find the minimum path\n    min_path = min(result, key=lambda x: x)\n    return min_path",
    "problem": {
      "problem_id": "HumanEval/129",
      "question": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "solutions": [
        "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"
      ],
      "starter_code": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 12
    },
    "base_score": 0.7000000000000001,
    "true_score": 0.7000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 36,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/129",
    "code": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    if n < 2 or k < 1:\n        return []\n\n    # Initialize the visited set and the result list\n    visited = set()\n    result = []\n\n    # Define the directions for moving up, down, left, right\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Helper function to perform DFS\n    def dfs(x, y, path, steps):\n        if steps == k:\n            result.append(path)\n            return\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n:\n                dfs(nx, ny, path + [grid[nx][ny]], steps + 1)\n        visited.remove((x, y))\n\n    # Start DFS from every cell\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, [grid[i][j]], 1)\n\n    # Find the minimum path\n    min_path = min(result, key=lambda x: x)\n    return min_path",
    "problem": {
      "problem_id": "HumanEval/129",
      "question": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "solutions": [
        "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"
      ],
      "starter_code": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 12
    },
    "base_score": 0.7000000000000001,
    "true_score": 0.7000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 36,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/129",
    "code": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    if n < 2 or k < 1:\n        return []\n\n    # Initialize the visited set and the result list\n    visited = set()\n    result = []\n\n    # Define the directions for moving up, down, left, right\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Helper function to perform DFS\n    def dfs(x, y, path, steps):\n        if steps == k:\n            result.append(path)\n            return\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n:\n                dfs(nx, ny, path + [grid[nx][ny]], steps + 1)\n        visited.remove((x, y))\n\n    # Start DFS from every cell\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, [grid[i][j]], 1)\n\n    # Find the minimum path\n    min_path = min(result, key=lambda x: x)\n    return min_path",
    "problem": {
      "problem_id": "HumanEval/129",
      "question": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "solutions": [
        "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"
      ],
      "starter_code": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 12
    },
    "base_score": 0.7000000000000001,
    "true_score": 0.7000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 36,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/129",
    "code": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    if n < 2 or k < 1:\n        return []\n\n    # Initialize the visited set and the queue with starting points\n    visited = set()\n    queue = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n\n    while queue:\n        value, x, y = queue.pop(0)\n        if (x, y) in visited or value > k:\n            continue\n        visited.add((x, y))\n\n        if value == k:\n            return [value]\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n:\n                queue.append((value + grid[nx][ny], nx, ny))\n\n    return []",
    "problem": {
      "problem_id": "HumanEval/129",
      "question": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "solutions": [
        "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"
      ],
      "starter_code": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 12
    },
    "base_score": 0.645,
    "true_score": 0.645,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/129",
    "code": "from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    n = len(grid)\n    if n < 2 or k < 1:\n        return []\n\n    directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\n    visited = set()\n    queue = [(grid[0][0], 0, [grid[0][0]])]\n\n    while queue:\n        value, steps, path = queue.pop(0)\n        if steps == k:\n            return path\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                new_path = path + [grid[nx][ny]]\n                queue.append((grid[nx][ny], steps + 1, new_path))\n\n    return []",
    "problem": {
      "problem_id": "HumanEval/129",
      "question": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "solutions": [
        "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"
      ],
      "starter_code": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 12
    },
    "base_score": 0.633,
    "true_score": 0.633,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_974",
    "code": "def minimum_total_path_sum(triangle):\n    n = len(triangle)\n    for i in range(1, n):\n        for j in range(i + 1):\n            triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n    return min(triangle[-1])",
    "problem": {
      "problem_id": "mbpp_974",
      "question": "Write a function to find the minimum total path sum in the given triangle.",
      "solutions": [
        "def min_sum_path(A): \r\n\tmemo = [None] * len(A) \r\n\tn = len(A) - 1\r\n\tfor i in range(len(A[n])): \r\n\t\tmemo[i] = A[n][i] \r\n\tfor i in range(len(A) - 2, -1,-1): \r\n\t\tfor j in range( len(A[i])): \r\n\t\t\tmemo[j] = A[i][j] + min(memo[j], \r\n\t\t\t\t\t\t\t\t\tmemo[j + 1]) \r\n\treturn memo[0]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the minimum total path sum in the given triangle.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.686,
    "true_score": 0.686,
    "generation_temperature": 0.5,
    "solution_length": 6,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_974",
    "code": "def minimum_total_path_sum(triangle):\n    n = len(triangle)\n    \n    # Start from the second last row and move upwards\n    for i in range(n-2, -1, -1):\n        for j in range(len(triangle[i])):\n            # Add the minimum of the two adjacent numbers from the row below to the current number\n            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\n    \n    # The top element now contains the minimum total path sum\n    return triangle[0][0]",
    "problem": {
      "problem_id": "mbpp_974",
      "question": "Write a function to find the minimum total path sum in the given triangle.",
      "solutions": [
        "def min_sum_path(A): \r\n\tmemo = [None] * len(A) \r\n\tn = len(A) - 1\r\n\tfor i in range(len(A[n])): \r\n\t\tmemo[i] = A[n][i] \r\n\tfor i in range(len(A) - 2, -1,-1): \r\n\t\tfor j in range( len(A[i])): \r\n\t\t\tmemo[j] = A[i][j] + min(memo[j], \r\n\t\t\t\t\t\t\t\t\tmemo[j + 1]) \r\n\treturn memo[0]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the minimum total path sum in the given triangle.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.681,
    "true_score": 0.681,
    "generation_temperature": 0.5,
    "solution_length": 11,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_974",
    "code": "def minimum_total_path_sum(triangle):\n    n = len(triangle)\n    for i in range(n-2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\n    return triangle[0][0]",
    "problem": {
      "problem_id": "mbpp_974",
      "question": "Write a function to find the minimum total path sum in the given triangle.",
      "solutions": [
        "def min_sum_path(A): \r\n\tmemo = [None] * len(A) \r\n\tn = len(A) - 1\r\n\tfor i in range(len(A[n])): \r\n\t\tmemo[i] = A[n][i] \r\n\tfor i in range(len(A) - 2, -1,-1): \r\n\t\tfor j in range( len(A[i])): \r\n\t\t\tmemo[j] = A[i][j] + min(memo[j], \r\n\t\t\t\t\t\t\t\t\tmemo[j + 1]) \r\n\treturn memo[0]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the minimum total path sum in the given triangle.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.666,
    "true_score": 0.666,
    "generation_temperature": 0.5,
    "solution_length": 6,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_974",
    "code": "def minimum_total_path_sum(triangle):\n    n = len(triangle)\n    for i in range(n-2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\n    return triangle[0][0]",
    "problem": {
      "problem_id": "mbpp_974",
      "question": "Write a function to find the minimum total path sum in the given triangle.",
      "solutions": [
        "def min_sum_path(A): \r\n\tmemo = [None] * len(A) \r\n\tn = len(A) - 1\r\n\tfor i in range(len(A[n])): \r\n\t\tmemo[i] = A[n][i] \r\n\tfor i in range(len(A) - 2, -1,-1): \r\n\t\tfor j in range( len(A[i])): \r\n\t\t\tmemo[j] = A[i][j] + min(memo[j], \r\n\t\t\t\t\t\t\t\t\tmemo[j + 1]) \r\n\treturn memo[0]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the minimum total path sum in the given triangle.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.666,
    "true_score": 0.666,
    "generation_temperature": 0.5,
    "solution_length": 6,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_974",
    "code": "def minimum_total_path_sum(triangle):\n    n = len(triangle)\n    for i in range(n-2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\n    return triangle[0][0]",
    "problem": {
      "problem_id": "mbpp_974",
      "question": "Write a function to find the minimum total path sum in the given triangle.",
      "solutions": [
        "def min_sum_path(A): \r\n\tmemo = [None] * len(A) \r\n\tn = len(A) - 1\r\n\tfor i in range(len(A[n])): \r\n\t\tmemo[i] = A[n][i] \r\n\tfor i in range(len(A) - 2, -1,-1): \r\n\t\tfor j in range( len(A[i])): \r\n\t\t\tmemo[j] = A[i][j] + min(memo[j], \r\n\t\t\t\t\t\t\t\t\tmemo[j + 1]) \r\n\treturn memo[0]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the minimum total path sum in the given triangle.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.666,
    "true_score": 0.666,
    "generation_temperature": 0.5,
    "solution_length": 6,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_974",
    "code": "def min_path_sum(triangle):\n    n = len(triangle)\n    for i in range(1, n):\n        for j in range(i + 1):\n            triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n    return min(triangle[-1])",
    "problem": {
      "problem_id": "mbpp_974",
      "question": "Write a function to find the minimum total path sum in the given triangle.",
      "solutions": [
        "def min_sum_path(A): \r\n\tmemo = [None] * len(A) \r\n\tn = len(A) - 1\r\n\tfor i in range(len(A[n])): \r\n\t\tmemo[i] = A[n][i] \r\n\tfor i in range(len(A) - 2, -1,-1): \r\n\t\tfor j in range( len(A[i])): \r\n\t\t\tmemo[j] = A[i][j] + min(memo[j], \r\n\t\t\t\t\t\t\t\t\tmemo[j + 1]) \r\n\treturn memo[0]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the minimum total path sum in the given triangle.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.638,
    "true_score": 0.638,
    "generation_temperature": 0.5,
    "solution_length": 6,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_721",
    "code": "def max_average_path(matrix):\n    n = len(matrix)\n    if n == 0:\n        return 0\n    \n    # Initialize the dp table with the same size as the matrix\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the dp table from bottom-right to top-left\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            if i == n-1 and j == n-1:\n                dp[i][j] = matrix[i][j]\n            else:\n                up = dp[i+1][j] if i < n-1 else float('-inf')\n                left = dp[i][j+1] if j < n-1 else float('-inf')\n                dp[i][j] = matrix[i][j] + max(up, left)\n    \n    # The maximum average path will be the maximum value in the dp table\n    return dp[0][0] / n",
    "problem": {
      "problem_id": "mbpp_721",
      "question": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
      "solutions": [
        "M = 100\r\ndef maxAverageOfPath(cost, N): \r\n\tdp = [[0 for i in range(N + 1)] for j in range(N + 1)] \r\n\tdp[0][0] = cost[0][0] \r\n\tfor i in range(1, N): \r\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0] \r\n\tfor j in range(1, N): \r\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j] \r\n\tfor i in range(1, N): \r\n\t\tfor j in range(1, N): \r\n\t\t\tdp[i][j] = max(dp[i - 1][j], \r\n\t\t\t\t\t\tdp[i][j - 1]) + cost[i][j] \r\n\treturn dp[N - 1][N - 1] / (2 * N - 1)"
      ],
      "starter_code": "def solution():\n    # Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.68,
    "true_score": 0.68,
    "generation_temperature": 0.5,
    "solution_length": 20,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_721",
    "code": "def max_average_path(matrix):\n    n = len(matrix)\n    if n == 0:\n        return 0\n\n    # Initialize variables to store the maximum average and the corresponding path\n    max_avg = float('-inf')\n    best_path = []\n\n    # Helper function to perform DFS and calculate the average of the current path\n    def dfs(x, y, path, current_avg):\n        nonlocal max_avg, best_path\n        if x < 0 or x >= n or y < 0 or y >= n:\n            return\n        if len(path) > n * n:\n            return\n\n        # Calculate the new average\n        new_avg = (current_avg + matrix[x][y]) / (len(path) + 1)\n\n        # Update the maximum average and best path if the new average is greater\n        if new_avg > max_avg:\n            max_avg = new_avg\n            best_path = path + [matrix[x][y]]\n\n        # Explore all four possible directions\n        dfs(x + 1, y, path + [matrix[x][y]], new_avg)\n        dfs(x - 1, y, path + [matrix[x][y]], new_avg)\n        dfs(x, y + 1, path + [matrix[x][y]], new_avg)\n        dfs(x, y - 1, path + [matrix[x][y]], new_avg)\n\n    # Start DFS from every cell\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, [], matrix[i][j])\n\n    return max_avg",
    "problem": {
      "problem_id": "mbpp_721",
      "question": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
      "solutions": [
        "M = 100\r\ndef maxAverageOfPath(cost, N): \r\n\tdp = [[0 for i in range(N + 1)] for j in range(N + 1)] \r\n\tdp[0][0] = cost[0][0] \r\n\tfor i in range(1, N): \r\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0] \r\n\tfor j in range(1, N): \r\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j] \r\n\tfor i in range(1, N): \r\n\t\tfor j in range(1, N): \r\n\t\t\tdp[i][j] = max(dp[i - 1][j], \r\n\t\t\t\t\t\tdp[i][j - 1]) + cost[i][j] \r\n\treturn dp[N - 1][N - 1] / (2 * N - 1)"
      ],
      "starter_code": "def solution():\n    # Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.653,
    "true_score": 0.653,
    "generation_temperature": 0.5,
    "solution_length": 37,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_721",
    "code": "def max_average_path(matrix):\n    n = len(matrix)\n    if n == 0:\n        return 0\n    \n    # Initialize the maximum average path to negative infinity\n    max_avg = float('-inf')\n    \n    # Iterate through each cell in the matrix\n    for i in range(n):\n        for j in range(n):\n            # Calculate the sum of the path starting from the current cell\n            path_sum = matrix[i][j]\n            path_length = 1\n            \n            # Explore all possible directions (up, down, left, right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                x, y = i + dx, j + dy\n                while 0 <= x < n and 0 <= y < n:\n                    path_sum += matrix[x][y]\n                    path_length += 1\n                    # Update the maximum average path found so far\n                    max_avg = max(max_avg, path_sum / path_length)\n    \n    return max_avg",
    "problem": {
      "problem_id": "mbpp_721",
      "question": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
      "solutions": [
        "M = 100\r\ndef maxAverageOfPath(cost, N): \r\n\tdp = [[0 for i in range(N + 1)] for j in range(N + 1)] \r\n\tdp[0][0] = cost[0][0] \r\n\tfor i in range(1, N): \r\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0] \r\n\tfor j in range(1, N): \r\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j] \r\n\tfor i in range(1, N): \r\n\t\tfor j in range(1, N): \r\n\t\t\tdp[i][j] = max(dp[i - 1][j], \r\n\t\t\t\t\t\tdp[i][j - 1]) + cost[i][j] \r\n\treturn dp[N - 1][N - 1] / (2 * N - 1)"
      ],
      "starter_code": "def solution():\n    # Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.618,
    "true_score": 0.618,
    "generation_temperature": 0.5,
    "solution_length": 25,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_721",
    "code": "def max_average_path(matrix):\n    n = len(matrix)\n    if n == 0:\n        return 0\n    \n    # Initialize the maximum average path to negative infinity\n    max_avg = float('-inf')\n    \n    # Iterate through each cell in the matrix\n    for i in range(n):\n        for j in range(n):\n            # Calculate the sum of the path starting from the current cell\n            path_sum = matrix[i][j]\n            path_length = 1\n            \n            # Explore all possible directions (up, down, left, right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                x, y = i + dx, j + dy\n                while 0 <= x < n and 0 <= y < n:\n                    path_sum += matrix[x][y]\n                    path_length += 1\n                    # Update the maximum average path found so far\n                    max_avg = max(max_avg, path_sum / path_length)\n    \n    return max_avg",
    "problem": {
      "problem_id": "mbpp_721",
      "question": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
      "solutions": [
        "M = 100\r\ndef maxAverageOfPath(cost, N): \r\n\tdp = [[0 for i in range(N + 1)] for j in range(N + 1)] \r\n\tdp[0][0] = cost[0][0] \r\n\tfor i in range(1, N): \r\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0] \r\n\tfor j in range(1, N): \r\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j] \r\n\tfor i in range(1, N): \r\n\t\tfor j in range(1, N): \r\n\t\t\tdp[i][j] = max(dp[i - 1][j], \r\n\t\t\t\t\t\tdp[i][j - 1]) + cost[i][j] \r\n\treturn dp[N - 1][N - 1] / (2 * N - 1)"
      ],
      "starter_code": "def solution():\n    # Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.618,
    "true_score": 0.618,
    "generation_temperature": 0.5,
    "solution_length": 25,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_721",
    "code": "def max_average_path(matrix):\n    n = len(matrix)\n    if n == 0:\n        return 0\n    \n    # Initialize the maximum average path to negative infinity\n    max_avg = float('-inf')\n    \n    # Iterate through each cell in the matrix\n    for i in range(n):\n        for j in range(n):\n            # Calculate the sum of the path starting from the current cell\n            path_sum = matrix[i][j]\n            path_length = 1\n            \n            # Explore all possible directions (up, down, left, right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                x, y = i + dx, j + dy\n                while 0 <= x < n and 0 <= y < n:\n                    path_sum += matrix[x][y]\n                    path_length += 1\n                    # Update the maximum average path found so far\n                    max_avg = max(max_avg, path_sum / path_length)\n    \n    return max_avg",
    "problem": {
      "problem_id": "mbpp_721",
      "question": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
      "solutions": [
        "M = 100\r\ndef maxAverageOfPath(cost, N): \r\n\tdp = [[0 for i in range(N + 1)] for j in range(N + 1)] \r\n\tdp[0][0] = cost[0][0] \r\n\tfor i in range(1, N): \r\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0] \r\n\tfor j in range(1, N): \r\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j] \r\n\tfor i in range(1, N): \r\n\t\tfor j in range(1, N): \r\n\t\t\tdp[i][j] = max(dp[i - 1][j], \r\n\t\t\t\t\t\tdp[i][j - 1]) + cost[i][j] \r\n\treturn dp[N - 1][N - 1] / (2 * N - 1)"
      ],
      "starter_code": "def solution():\n    # Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.618,
    "true_score": 0.618,
    "generation_temperature": 0.5,
    "solution_length": 25,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_721",
    "code": "def max_average_path(matrix):\n    n = len(matrix)\n    if n == 0:\n        return 0\n    \n    # Initialize the maximum average path\n    max_avg = float('-inf')\n    \n    # Iterate through each cell in the matrix\n    for i in range(n):\n        for j in range(n):\n            # Calculate the sum of the path starting from the current cell\n            path_sum = matrix[i][j]\n            path_length = 1\n            \n            # Explore all possible directions (up, down, left, right)\n            for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n                x, y = i + dx, j + dy\n                while 0 <= x < n and 0 <= y < n:\n                    path_sum += matrix[x][y]\n                    path_length += 1\n                    # Update the maximum average path\n                    max_avg = max(max_avg, path_sum / path_length)\n    \n    return max_avg",
    "problem": {
      "problem_id": "mbpp_721",
      "question": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
      "solutions": [
        "M = 100\r\ndef maxAverageOfPath(cost, N): \r\n\tdp = [[0 for i in range(N + 1)] for j in range(N + 1)] \r\n\tdp[0][0] = cost[0][0] \r\n\tfor i in range(1, N): \r\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0] \r\n\tfor j in range(1, N): \r\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j] \r\n\tfor i in range(1, N): \r\n\t\tfor j in range(1, N): \r\n\t\t\tdp[i][j] = max(dp[i - 1][j], \r\n\t\t\t\t\t\tdp[i][j - 1]) + cost[i][j] \r\n\treturn dp[N - 1][N - 1] / (2 * N - 1)"
      ],
      "starter_code": "def solution():\n    # Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.618,
    "true_score": 0.618,
    "generation_temperature": 0.5,
    "solution_length": 25,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/6",
    "code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    current_depth = 0\n    max_depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ')':\n            current_depth -= 1\n\n        if char == ' ' and current_depth == 0:\n            result.append(max_depth)\n            max_depth = 0\n\n    return result",
    "problem": {
      "problem_id": "HumanEval/6",
      "question": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "solutions": [
        "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
      ],
      "starter_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 4
    },
    "base_score": 0.71,
    "true_score": 0.71,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/6",
    "code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    stack = []\n    max_depth = 0\n    current_depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n            current_depth += 1\n            if current_depth > max_depth:\n                max_depth = current_depth\n        elif char == ')':\n            stack.pop()\n            current_depth -= 1\n\n    return [max_depth]",
    "problem": {
      "problem_id": "HumanEval/6",
      "question": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "solutions": [
        "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
      ],
      "starter_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 4
    },
    "base_score": 0.6470000000000001,
    "true_score": 0.6470000000000001,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/6",
    "code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    result = []\n    current_depth = 0\n    max_depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ')':\n            current_depth -= 1\n\n        if current_depth == 0:\n            result.append(max_depth)\n            max_depth = 0\n\n    return result",
    "problem": {
      "problem_id": "HumanEval/6",
      "question": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "solutions": [
        "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
      ],
      "starter_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 4
    },
    "base_score": 0.642,
    "true_score": 0.642,
    "generation_temperature": 0.5,
    "solution_length": 20,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/6",
    "code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    result = []\n    current_depth = 0\n    max_depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ')':\n            current_depth -= 1\n\n        if current_depth == 0:\n            result.append(max_depth)\n            max_depth = 0\n\n    return result",
    "problem": {
      "problem_id": "HumanEval/6",
      "question": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "solutions": [
        "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
      ],
      "starter_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 4
    },
    "base_score": 0.642,
    "true_score": 0.642,
    "generation_temperature": 0.5,
    "solution_length": 20,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/6",
    "code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    result = []\n    current_depth = 0\n    max_depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ')':\n            current_depth -= 1\n\n        if current_depth == 0:\n            result.append(max_depth)\n            max_depth = 0\n\n    return result",
    "problem": {
      "problem_id": "HumanEval/6",
      "question": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "solutions": [
        "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
      ],
      "starter_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 4
    },
    "base_score": 0.642,
    "true_score": 0.642,
    "generation_temperature": 0.5,
    "solution_length": 20,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/6",
    "code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    result = []\n    current_depth = 0\n    max_depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ')':\n            current_depth -= 1\n\n        if current_depth == 0:\n            result.append(max_depth)\n\n    return result",
    "problem": {
      "problem_id": "HumanEval/6",
      "question": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "solutions": [
        "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
      ],
      "starter_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 4
    },
    "base_score": 0.642,
    "true_score": 0.642,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v0",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v0",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v0",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v0",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v0",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v0",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v0",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index, right_index = 0, 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n    \n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n    \n    return merged",
    "problem": {
      "problem_id": "hard_003_v0",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v0",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged",
    "problem": {
      "problem_id": "hard_003_v0",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v0",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v0",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v1",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v1",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v1",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v1",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v1",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v1",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v1",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v1",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v1",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v1",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v1",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged",
    "problem": {
      "problem_id": "hard_003_v1",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v2",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v2",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v2",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v2",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v2",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v2",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v2",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v2",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v2",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v2",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v2",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n    \n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n    \n    return merged",
    "problem": {
      "problem_id": "hard_003_v2",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v3",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v3",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v3",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v3",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v3",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v3",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v3",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged",
    "problem": {
      "problem_id": "hard_003_v3",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v3",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v3",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v3",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index, right_index = 0, 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n    \n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n    \n    return merged",
    "problem": {
      "problem_id": "hard_003_v3",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v4",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v4",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v4",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v4",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v4",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v4",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v4",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v4",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v4",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged",
    "problem": {
      "problem_id": "hard_003_v4",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v4",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v4",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/95",
    "code": "def check_dict_case(dict):\n    if not dict:\n        return False\n    \n    all_lower = all(key.islower() for key in dict.keys())\n    all_upper = all(key.isupper() for key in dict.keys())\n    \n    return all_lower or all_upper",
    "problem": {
      "problem_id": "HumanEval/95",
      "question": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "solutions": [
        "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
      ],
      "starter_code": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.662,
    "true_score": 0.662,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/95",
    "code": "def check_dict_case(dict):\n    if not dict:\n        return False\n    \n    all_lower = all(key.islower() for key in dict.keys())\n    all_upper = all(key.isupper() for key in dict.keys())\n    \n    return all_lower or all_upper",
    "problem": {
      "problem_id": "HumanEval/95",
      "question": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "solutions": [
        "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
      ],
      "starter_code": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.662,
    "true_score": 0.662,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/95",
    "code": "def check_dict_case(dict):\n    if not dict:\n        return False\n    \n    all_lower = all(key.islower() for key in dict.keys())\n    all_upper = all(key.isupper() for key in dict.keys())\n    \n    return all_lower or all_upper",
    "problem": {
      "problem_id": "HumanEval/95",
      "question": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "solutions": [
        "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
      ],
      "starter_code": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.662,
    "true_score": 0.662,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/95",
    "code": "def check_dict_case(dict):\n    if not dict:\n        return False\n    \n    all_lower = all(key.islower() for key in dict.keys())\n    all_upper = all(key.isupper() for key in dict.keys())\n    \n    return all_lower or all_upper",
    "problem": {
      "problem_id": "HumanEval/95",
      "question": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "solutions": [
        "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
      ],
      "starter_code": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.662,
    "true_score": 0.662,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/95",
    "code": "def check_dict_case(dict):\n    if not dict:\n        return False\n\n    all_lower = all(key.islower() for key in dict.keys())\n    all_upper = all(key.isupper() for key in dict.keys())\n\n    return all_lower or all_upper",
    "problem": {
      "problem_id": "HumanEval/95",
      "question": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "solutions": [
        "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
      ],
      "starter_code": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.662,
    "true_score": 0.662,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/95",
    "code": "def check_dict_case(dict):\n    if not dict:\n        return False\n    \n    all_lower = all(key.islower() for key in dict.keys())\n    all_upper = all(key.isupper() for key in dict.keys())\n    \n    return all_lower or all_upper",
    "problem": {
      "problem_id": "HumanEval/95",
      "question": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "solutions": [
        "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
      ],
      "starter_code": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.662,
    "true_score": 0.662,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/59",
    "code": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n    \n    largest_factor = -1\n    \n    # Divide n by 2 until it's odd\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Check for odd factors from 3 onwards\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor",
    "problem": {
      "problem_id": "HumanEval/59",
      "question": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
      ],
      "starter_code": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 6
    },
    "base_score": 0.7050000000000001,
    "true_score": 0.7050000000000001,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/59",
    "code": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n    \n    largest_factor = -1\n    \n    # Divide n by 2 until it's odd\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Check for odd factors from 3 onwards\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor",
    "problem": {
      "problem_id": "HumanEval/59",
      "question": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
      ],
      "starter_code": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 6
    },
    "base_score": 0.7050000000000001,
    "true_score": 0.7050000000000001,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/59",
    "code": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n    \n    largest_factor = -1\n    \n    # Divide n by 2 until it's odd\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Check for odd factors from 3 onwards\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor",
    "problem": {
      "problem_id": "HumanEval/59",
      "question": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
      ],
      "starter_code": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 6
    },
    "base_score": 0.7050000000000001,
    "true_score": 0.7050000000000001,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/59",
    "code": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n    \n    largest_factor = -1\n    \n    # Divide n by 2 until it's odd\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Check for odd factors from 3 onwards\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor",
    "problem": {
      "problem_id": "HumanEval/59",
      "question": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
      ],
      "starter_code": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 6
    },
    "base_score": 0.7050000000000001,
    "true_score": 0.7050000000000001,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/59",
    "code": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n    \n    largest_factor = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # n must be odd at this point, so we can skip one element (Note i = i + 2)\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, add i and divide n\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    \n    # This condition is to handle the case when n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor",
    "problem": {
      "problem_id": "HumanEval/59",
      "question": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
      ],
      "starter_code": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 6
    },
    "base_score": 0.7050000000000001,
    "true_score": 0.7050000000000001,
    "generation_temperature": 0.5,
    "solution_length": 29,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/59",
    "code": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n    \n    largest_factor = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # n must be odd at this point, so we can skip one element (Note i = i + 2)\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, add i and divide n\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    \n    # This condition is to handle the case when n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor",
    "problem": {
      "problem_id": "HumanEval/59",
      "question": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
      ],
      "starter_code": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 6
    },
    "base_score": 0.7050000000000001,
    "true_score": 0.7050000000000001,
    "generation_temperature": 0.5,
    "solution_length": 29,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/75",
    "code": "def is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n    if a < 2:\n        return False\n    \n    prime_count = 0\n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0:\n            while a % i == 0:\n                a //= i\n            prime_count += 1\n    \n    if a > 1:\n        prime_count += 1\n    \n    return prime_count == 3",
    "problem": {
      "problem_id": "HumanEval/75",
      "question": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
      ],
      "starter_code": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.7000000000000001,
    "true_score": 0.7000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 22,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/75",
    "code": "def is_multiply_prime(a):\n    if a < 2:\n        return False\n    \n    prime_factors = []\n    \n    # Check for divisibility by 2\n    while a % 2 == 0:\n        prime_factors.append(2)\n        a //= 2\n    \n    # Check for odd factors from 3 to sqrt(a)\n    for i in range(3, int(math.sqrt(a)) + 1, 2):\n        while a % i == 0:\n            prime_factors.append(i)\n            a //= i\n    \n    # If a is a prime number greater than 2\n    if a > 2:\n        prime_factors.append(a)\n    \n    # Check if there are exactly three prime factors\n    return len(prime_factors) == 3",
    "problem": {
      "problem_id": "HumanEval/75",
      "question": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
      ],
      "starter_code": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.648,
    "true_score": 0.648,
    "generation_temperature": 0.5,
    "solution_length": 23,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/75",
    "code": "def is_multiply_prime(a):\n    if a >= 100:\n        return False\n    \n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    \n    count = 0\n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0:\n            if is_prime(i):\n                count += 1\n            if is_prime(a // i):\n                count += 1\n            if count > 3:\n                return False\n    if count == 3:\n        return True\n    return False",
    "problem": {
      "problem_id": "HumanEval/75",
      "question": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
      ],
      "starter_code": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.6030000000000002,
    "true_score": 0.6030000000000002,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/75",
    "code": "def is_multiply_prime(a):\n    if a >= 100:\n        return False\n    \n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    \n    count = 0\n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0:\n            if is_prime(i):\n                count += 1\n            if is_prime(a // i):\n                count += 1\n            if count > 3:\n                return False\n    if count == 3:\n        return True\n    return False",
    "problem": {
      "problem_id": "HumanEval/75",
      "question": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
      ],
      "starter_code": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.6030000000000002,
    "true_score": 0.6030000000000002,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/75",
    "code": "def is_multiply_prime(a):\n    if a >= 100:\n        return False\n    \n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n    \n    count = 0\n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0:\n            if is_prime(i):\n                count += 1\n            if is_prime(a // i):\n                count += 1\n            if count > 3:\n                return False\n    if count == 3:\n        return True\n    return False",
    "problem": {
      "problem_id": "HumanEval/75",
      "question": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
      ],
      "starter_code": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.6030000000000002,
    "true_score": 0.6030000000000002,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/75",
    "code": "def is_multiply_prime(a):\n    if a < 2:\n        return False\n    count = 0\n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0:\n            count += 1\n            if count > 3:\n                return False\n    if count == 3:\n        return True\n    return False",
    "problem": {
      "problem_id": "HumanEval/75",
      "question": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
      ],
      "starter_code": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.5980000000000001,
    "true_score": 0.5980000000000001,
    "generation_temperature": 0.5,
    "solution_length": 12,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v0",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v0",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v0",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v0",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v0",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v0",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v0",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v0",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v0",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v0",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v0",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v0",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v1",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v1",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v1",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v1",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v1",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v1",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v1",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v1",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v1",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v1",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v1",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v1",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v2",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v2",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v2",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v2",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v2",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v2",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v2",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v2",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v2",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v2",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v2",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v2",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v3",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v3",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v3",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v3",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v3",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v3",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v3",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v3",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v3",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v3",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v3",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v3",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v4",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v4",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v4",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v4",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v4",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v4",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v4",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v4",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v4",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v4",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v4",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v4",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_859",
    "code": "def generate_sublists(nums):\n    \"\"\"\n    Generate all sublists of a given list.\n\n    Args:\n    nums (list): The input list.\n\n    Returns:\n    list: A list containing all sublists of the input list.\n    \"\"\"\n    if not nums:\n        return [[]]\n\n    first_element = nums[0]\n    rest_sublists = generate_sublists(nums[1:])\n    all_sublists = rest_sublists.copy()\n\n    for sublist in rest_sublists:\n        new_sublist = [first_element] + sublist\n        all_sublists.append(new_sublist)\n\n    return all_sublists",
    "problem": {
      "problem_id": "mbpp_859",
      "question": "Write a function to generate all sublists of a given list.",
      "solutions": [
        "from itertools import combinations\r\ndef sub_lists(my_list):\r\n\tsubs = []\r\n\tfor i in range(0, len(my_list)+1):\r\n\t  temp = [list(x) for x in combinations(my_list, i)]\r\n\t  if len(temp)>0:\r\n\t    subs.extend(temp)\r\n\treturn subs"
      ],
      "starter_code": "def solution():\n    # Write a function to generate all sublists of a given list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6950000000000001,
    "true_score": 0.6950000000000001,
    "generation_temperature": 0.5,
    "solution_length": 22,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_859",
    "code": "def generate_sublists(nums):\n    if not nums:\n        return [[]]\n    \n    first_element = nums[0]\n    rest_sublists = generate_sublists(nums[1:])\n    \n    return rest_sublists + [[first_element] + sublist for sublist in rest_sublists]",
    "problem": {
      "problem_id": "mbpp_859",
      "question": "Write a function to generate all sublists of a given list.",
      "solutions": [
        "from itertools import combinations\r\ndef sub_lists(my_list):\r\n\tsubs = []\r\n\tfor i in range(0, len(my_list)+1):\r\n\t  temp = [list(x) for x in combinations(my_list, i)]\r\n\t  if len(temp)>0:\r\n\t    subs.extend(temp)\r\n\treturn subs"
      ],
      "starter_code": "def solution():\n    # Write a function to generate all sublists of a given list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.66,
    "true_score": 0.66,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_859",
    "code": "def generate_sublists(nums):\n    if not nums:\n        return [[]]\n    \n    first_element = nums[0]\n    rest_sublists = generate_sublists(nums[1:])\n    \n    return rest_sublists + [[first_element] + sublist for sublist in rest_sublists]",
    "problem": {
      "problem_id": "mbpp_859",
      "question": "Write a function to generate all sublists of a given list.",
      "solutions": [
        "from itertools import combinations\r\ndef sub_lists(my_list):\r\n\tsubs = []\r\n\tfor i in range(0, len(my_list)+1):\r\n\t  temp = [list(x) for x in combinations(my_list, i)]\r\n\t  if len(temp)>0:\r\n\t    subs.extend(temp)\r\n\treturn subs"
      ],
      "starter_code": "def solution():\n    # Write a function to generate all sublists of a given list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.66,
    "true_score": 0.66,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_859",
    "code": "def generate_sublists(nums):\n    if not nums:\n        return [[]]\n    \n    first_element = nums[0]\n    rest_sublists = generate_sublists(nums[1:])\n    \n    return rest_sublists + [[first_element] + sublist for sublist in rest_sublists]",
    "problem": {
      "problem_id": "mbpp_859",
      "question": "Write a function to generate all sublists of a given list.",
      "solutions": [
        "from itertools import combinations\r\ndef sub_lists(my_list):\r\n\tsubs = []\r\n\tfor i in range(0, len(my_list)+1):\r\n\t  temp = [list(x) for x in combinations(my_list, i)]\r\n\t  if len(temp)>0:\r\n\t    subs.extend(temp)\r\n\treturn subs"
      ],
      "starter_code": "def solution():\n    # Write a function to generate all sublists of a given list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.66,
    "true_score": 0.66,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_859",
    "code": "def generate_sublists(nums):\n    if not nums:\n        return [[]]\n    \n    first_element = nums[0]\n    rest_sublists = generate_sublists(nums[1:])\n    \n    new_sublists = []\n    for sublist in rest_sublists:\n        new_sublists.append([first_element] + sublist)\n        new_sublists.append(sublist)\n    \n    return new_sublists",
    "problem": {
      "problem_id": "mbpp_859",
      "question": "Write a function to generate all sublists of a given list.",
      "solutions": [
        "from itertools import combinations\r\ndef sub_lists(my_list):\r\n\tsubs = []\r\n\tfor i in range(0, len(my_list)+1):\r\n\t  temp = [list(x) for x in combinations(my_list, i)]\r\n\t  if len(temp)>0:\r\n\t    subs.extend(temp)\r\n\treturn subs"
      ],
      "starter_code": "def solution():\n    # Write a function to generate all sublists of a given list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.66,
    "true_score": 0.66,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_859",
    "code": "def generate_sublists(nums):\n    if not nums:\n        return [[]]\n    \n    first_element = nums[0]\n    rest_sublists = generate_sublists(nums[1:])\n    \n    return rest_sublists + [[first_element] + sublist for sublist in rest_sublists]",
    "problem": {
      "problem_id": "mbpp_859",
      "question": "Write a function to generate all sublists of a given list.",
      "solutions": [
        "from itertools import combinations\r\ndef sub_lists(my_list):\r\n\tsubs = []\r\n\tfor i in range(0, len(my_list)+1):\r\n\t  temp = [list(x) for x in combinations(my_list, i)]\r\n\t  if len(temp)>0:\r\n\t    subs.extend(temp)\r\n\treturn subs"
      ],
      "starter_code": "def solution():\n    # Write a function to generate all sublists of a given list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.66,
    "true_score": 0.66,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_620",
    "code": "from typing import List\n\ndef largest_divisible_subset(nums: List[int]) -> List[int]:\n    if not nums:\n        return []\n\n    nums.sort()\n    dp = [1] * len(nums)\n    prev = [-1] * len(nums)\n\n    max_length = 0\n    max_index = 0\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                prev[i] = j\n\n    for i in range(len(dp)):\n        if dp[i] > max_length:\n            max_length = dp[i]\n            max_index = i\n\n    result = []\n    while max_index != -1:\n        result.append(nums[max_index])\n        max_index = prev[max_index]\n\n    return result[::-1]",
    "problem": {
      "problem_id": "mbpp_620",
      "question": "Write a function to find the largest subset where each pair is divisible.",
      "solutions": [
        "def largest_subset(a, n):\r\n\tdp = [0 for i in range(n)]\r\n\tdp[n - 1] = 1; \r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tmxm = 0;\r\n\t\tfor j in range(i + 1, n):\r\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\r\n\t\t\t\tmxm = max(mxm, dp[j])\r\n\t\tdp[i] = 1 + mxm\r\n\treturn max(dp)"
      ],
      "starter_code": "def solution():\n    # Write a function to find the largest subset where each pair is divisible.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6864285714285715,
    "true_score": 0.6864285714285715,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_620",
    "code": "from typing import List\n\ndef largest_divisible_subset(nums: List[int]) -> List[int]:\n    if not nums:\n        return []\n\n    nums.sort()\n    dp = [1] * len(nums)\n    prev = [-1] * len(nums)\n\n    max_length = 0\n    max_index = 0\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                prev[i] = j\n\n    for i in range(len(dp)):\n        if dp[i] > max_length:\n            max_length = dp[i]\n            max_index = i\n\n    result = []\n    while max_index != -1:\n        result.append(nums[max_index])\n        max_index = prev[max_index]\n\n    return result[::-1]",
    "problem": {
      "problem_id": "mbpp_620",
      "question": "Write a function to find the largest subset where each pair is divisible.",
      "solutions": [
        "def largest_subset(a, n):\r\n\tdp = [0 for i in range(n)]\r\n\tdp[n - 1] = 1; \r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tmxm = 0;\r\n\t\tfor j in range(i + 1, n):\r\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\r\n\t\t\t\tmxm = max(mxm, dp[j])\r\n\t\tdp[i] = 1 + mxm\r\n\treturn max(dp)"
      ],
      "starter_code": "def solution():\n    # Write a function to find the largest subset where each pair is divisible.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6864285714285715,
    "true_score": 0.6864285714285715,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_620",
    "code": "from typing import List\n\ndef largest_divisible_subset(nums: List[int]) -> List[int]:\n    if not nums:\n        return []\n\n    nums.sort()\n    dp = [1] * len(nums)\n    prev = [-1] * len(nums)\n\n    max_length = 0\n    max_index = 0\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                prev[i] = j\n\n    for i in range(len(dp)):\n        if dp[i] > max_length:\n            max_length = dp[i]\n            max_index = i\n\n    result = []\n    while max_index != -1:\n        result.append(nums[max_index])\n        max_index = prev[max_index]\n\n    return result[::-1]",
    "problem": {
      "problem_id": "mbpp_620",
      "question": "Write a function to find the largest subset where each pair is divisible.",
      "solutions": [
        "def largest_subset(a, n):\r\n\tdp = [0 for i in range(n)]\r\n\tdp[n - 1] = 1; \r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tmxm = 0;\r\n\t\tfor j in range(i + 1, n):\r\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\r\n\t\t\t\tmxm = max(mxm, dp[j])\r\n\t\tdp[i] = 1 + mxm\r\n\treturn max(dp)"
      ],
      "starter_code": "def solution():\n    # Write a function to find the largest subset where each pair is divisible.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6864285714285715,
    "true_score": 0.6864285714285715,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_620",
    "code": "def largest_divisible_subset(nums):\n    if not nums:\n        return []\n\n    nums.sort()\n    dp = [1] * len(nums)\n    prev_index = [-1] * len(nums)\n\n    max_length = 0\n    max_index = 0\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                prev_index[i] = j\n\n    for i in range(len(dp)):\n        if dp[i] > max_length:\n            max_length = dp[i]\n            max_index = i\n\n    result = []\n    while max_index != -1:\n        result.append(nums[max_index])\n        max_index = prev_index[max_index]\n\n    return result[::-1]",
    "problem": {
      "problem_id": "mbpp_620",
      "question": "Write a function to find the largest subset where each pair is divisible.",
      "solutions": [
        "def largest_subset(a, n):\r\n\tdp = [0 for i in range(n)]\r\n\tdp[n - 1] = 1; \r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tmxm = 0;\r\n\t\tfor j in range(i + 1, n):\r\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\r\n\t\t\t\tmxm = max(mxm, dp[j])\r\n\t\tdp[i] = 1 + mxm\r\n\treturn max(dp)"
      ],
      "starter_code": "def solution():\n    # Write a function to find the largest subset where each pair is divisible.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6864285714285715,
    "true_score": 0.6864285714285715,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_620",
    "code": "from typing import List\n\ndef largest_divisible_subset(nums: List[int]) -> List[int]:\n    if not nums:\n        return []\n\n    nums.sort()\n    dp = [1] * len(nums)\n    prev = [-1] * len(nums)\n\n    max_length = 0\n    max_index = 0\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                prev[i] = j\n\n    for i in range(len(dp)):\n        if dp[i] > max_length:\n            max_length = dp[i]\n            max_index = i\n\n    result = []\n    while max_index != -1:\n        result.append(nums[max_index])\n        max_index = prev[max_index]\n\n    return result[::-1]",
    "problem": {
      "problem_id": "mbpp_620",
      "question": "Write a function to find the largest subset where each pair is divisible.",
      "solutions": [
        "def largest_subset(a, n):\r\n\tdp = [0 for i in range(n)]\r\n\tdp[n - 1] = 1; \r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tmxm = 0;\r\n\t\tfor j in range(i + 1, n):\r\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\r\n\t\t\t\tmxm = max(mxm, dp[j])\r\n\t\tdp[i] = 1 + mxm\r\n\treturn max(dp)"
      ],
      "starter_code": "def solution():\n    # Write a function to find the largest subset where each pair is divisible.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6864285714285715,
    "true_score": 0.6864285714285715,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_620",
    "code": "def largest_divisible_subset(nums):\n    if not nums:\n        return []\n\n    nums.sort()\n    dp = [1] * len(nums)\n    prev = [-1] * len(nums)\n\n    max_length = 0\n    max_index = 0\n\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                prev[i] = j\n\n    for i in range(len(dp)):\n        if dp[i] > max_length:\n            max_length = dp[i]\n            max_index = i\n\n    result = []\n    while max_index != -1:\n        result.append(nums[max_index])\n        max_index = prev[max_index]\n\n    return result[::-1]",
    "problem": {
      "problem_id": "mbpp_620",
      "question": "Write a function to find the largest subset where each pair is divisible.",
      "solutions": [
        "def largest_subset(a, n):\r\n\tdp = [0 for i in range(n)]\r\n\tdp[n - 1] = 1; \r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tmxm = 0;\r\n\t\tfor j in range(i + 1, n):\r\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\r\n\t\t\t\tmxm = max(mxm, dp[j])\r\n\t\tdp[i] = 1 + mxm\r\n\treturn max(dp)"
      ],
      "starter_code": "def solution():\n    # Write a function to find the largest subset where each pair is divisible.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6864285714285715,
    "true_score": 0.6864285714285715,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_849",
    "code": "def sum_of_prime_divisors(n):\n    if n <= 1:\n        return 0\n    \n    prime_sum = 0\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            prime_sum += divisor\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        prime_sum += n\n    \n    return prime_sum",
    "problem": {
      "problem_id": "mbpp_849",
      "question": "Write a python function to find sum of all prime divisors of a given number.",
      "solutions": [
        "def Sum(N): \r\n    SumOfPrimeDivisors = [0]*(N + 1)   \r\n    for i in range(2,N + 1) : \r\n        if (SumOfPrimeDivisors[i] == 0) : \r\n            for j in range(i,N + 1,i) : \r\n                SumOfPrimeDivisors[j] += i           \r\n    return SumOfPrimeDivisors[N] "
      ],
      "starter_code": "def solution():\n    # Write a python function to find sum of all prime divisors of a given number.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5980000000000001,
    "true_score": 0.5980000000000001,
    "generation_temperature": 0.5,
    "solution_length": 17,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_849",
    "code": "def sum_of_prime_divisors(n):\n    if n <= 1:\n        return 0\n    \n    prime_sum = 0\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            prime_sum += divisor\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        prime_sum += n\n    \n    return prime_sum",
    "problem": {
      "problem_id": "mbpp_849",
      "question": "Write a python function to find sum of all prime divisors of a given number.",
      "solutions": [
        "def Sum(N): \r\n    SumOfPrimeDivisors = [0]*(N + 1)   \r\n    for i in range(2,N + 1) : \r\n        if (SumOfPrimeDivisors[i] == 0) : \r\n            for j in range(i,N + 1,i) : \r\n                SumOfPrimeDivisors[j] += i           \r\n    return SumOfPrimeDivisors[N] "
      ],
      "starter_code": "def solution():\n    # Write a python function to find sum of all prime divisors of a given number.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5980000000000001,
    "true_score": 0.5980000000000001,
    "generation_temperature": 0.5,
    "solution_length": 17,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_849",
    "code": "def sum_of_prime_divisors(n):\n    if n <= 1:\n        return 0\n    \n    prime_sum = 0\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            prime_sum += divisor\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        prime_sum += n\n    \n    return prime_sum",
    "problem": {
      "problem_id": "mbpp_849",
      "question": "Write a python function to find sum of all prime divisors of a given number.",
      "solutions": [
        "def Sum(N): \r\n    SumOfPrimeDivisors = [0]*(N + 1)   \r\n    for i in range(2,N + 1) : \r\n        if (SumOfPrimeDivisors[i] == 0) : \r\n            for j in range(i,N + 1,i) : \r\n                SumOfPrimeDivisors[j] += i           \r\n    return SumOfPrimeDivisors[N] "
      ],
      "starter_code": "def solution():\n    # Write a python function to find sum of all prime divisors of a given number.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5980000000000001,
    "true_score": 0.5980000000000001,
    "generation_temperature": 0.5,
    "solution_length": 17,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_849",
    "code": "def sum_of_prime_divisors(n):\n    if n <= 1:\n        return 0\n    \n    prime_sum = 0\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            prime_sum += divisor\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        prime_sum += n\n    \n    return prime_sum",
    "problem": {
      "problem_id": "mbpp_849",
      "question": "Write a python function to find sum of all prime divisors of a given number.",
      "solutions": [
        "def Sum(N): \r\n    SumOfPrimeDivisors = [0]*(N + 1)   \r\n    for i in range(2,N + 1) : \r\n        if (SumOfPrimeDivisors[i] == 0) : \r\n            for j in range(i,N + 1,i) : \r\n                SumOfPrimeDivisors[j] += i           \r\n    return SumOfPrimeDivisors[N] "
      ],
      "starter_code": "def solution():\n    # Write a python function to find sum of all prime divisors of a given number.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5980000000000001,
    "true_score": 0.5980000000000001,
    "generation_temperature": 0.5,
    "solution_length": 17,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_849",
    "code": "def sum_of_prime_divisors(n):\n    if n <= 1:\n        return 0\n    \n    prime_sum = 0\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            prime_sum += divisor\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        prime_sum += n\n    \n    return prime_sum",
    "problem": {
      "problem_id": "mbpp_849",
      "question": "Write a python function to find sum of all prime divisors of a given number.",
      "solutions": [
        "def Sum(N): \r\n    SumOfPrimeDivisors = [0]*(N + 1)   \r\n    for i in range(2,N + 1) : \r\n        if (SumOfPrimeDivisors[i] == 0) : \r\n            for j in range(i,N + 1,i) : \r\n                SumOfPrimeDivisors[j] += i           \r\n    return SumOfPrimeDivisors[N] "
      ],
      "starter_code": "def solution():\n    # Write a python function to find sum of all prime divisors of a given number.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5980000000000001,
    "true_score": 0.5980000000000001,
    "generation_temperature": 0.5,
    "solution_length": 17,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_849",
    "code": "from typing import List\n\ndef sum_of_prime_divisors(n: int) -> int:\n    if n <= 1:\n        return 0\n    \n    prime_sum = 0\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            prime_sum += divisor\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        prime_sum += n\n    \n    return prime_sum",
    "problem": {
      "problem_id": "mbpp_849",
      "question": "Write a python function to find sum of all prime divisors of a given number.",
      "solutions": [
        "def Sum(N): \r\n    SumOfPrimeDivisors = [0]*(N + 1)   \r\n    for i in range(2,N + 1) : \r\n        if (SumOfPrimeDivisors[i] == 0) : \r\n            for j in range(i,N + 1,i) : \r\n                SumOfPrimeDivisors[j] += i           \r\n    return SumOfPrimeDivisors[N] "
      ],
      "starter_code": "def solution():\n    # Write a python function to find sum of all prime divisors of a given number.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5980000000000001,
    "true_score": 0.5980000000000001,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_950",
    "code": "def chinese_zodiac_sign(year):\n    # Check if the input year is valid\n    if not isinstance(year, int) or year < 0:\n        raise ValueError(\"Year must be a non-negative integer\")\n    \n    # Chinese zodiac signs based on the year modulo 12\n    zodiacs = [\"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\", \"Tiger\", \"Hare\", \"Dragon\", \"Snake\", \"Horse\"]\n    \n    # Calculate the index of the zodiac sign\n    index = year % 12\n    \n    # Return the corresponding zodiac sign\n    return zodiacs[index]",
    "problem": {
      "problem_id": "mbpp_950",
      "question": "Write a function to display sign of the chinese zodiac for given year.",
      "solutions": [
        "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign"
      ],
      "starter_code": "def solution():\n    # Write a function to display sign of the chinese zodiac for given year.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6910000000000001,
    "true_score": 0.6910000000000001,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_950",
    "code": "def chinese_zodiac_sign(year):\n    # Check if the input year is valid\n    if not isinstance(year, int) or year < 0:\n        raise ValueError(\"Year must be a non-negative integer\")\n    \n    # Chinese zodiac signs based on the year modulo 12\n    zodiacs = [\"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\", \"Tiger\", \"Hare\", \"Dragon\", \"Snake\", \"Horse\"]\n    \n    # Calculate the index of the zodiac sign\n    index = year % 12\n    \n    # Return the corresponding zodiac sign\n    return zodiacs[index]",
    "problem": {
      "problem_id": "mbpp_950",
      "question": "Write a function to display sign of the chinese zodiac for given year.",
      "solutions": [
        "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign"
      ],
      "starter_code": "def solution():\n    # Write a function to display sign of the chinese zodiac for given year.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6910000000000001,
    "true_score": 0.6910000000000001,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_950",
    "code": "def chinese_zodiac_sign(year):\n    # Check if the input year is valid\n    if not isinstance(year, int) or year < 0:\n        raise ValueError(\"Year must be a non-negative integer\")\n    \n    # Chinese zodiac signs based on the year modulo 12\n    zodiacs = [\"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\", \"Tiger\", \"Hare\", \"Dragon\", \"Snake\", \"Horse\"]\n    \n    # Calculate the index of the zodiac sign\n    index = year % 12\n    \n    # Return the corresponding zodiac sign\n    return zodiacs[index]",
    "problem": {
      "problem_id": "mbpp_950",
      "question": "Write a function to display sign of the chinese zodiac for given year.",
      "solutions": [
        "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign"
      ],
      "starter_code": "def solution():\n    # Write a function to display sign of the chinese zodiac for given year.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6910000000000001,
    "true_score": 0.6910000000000001,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_950",
    "code": "def chinese_zodiac_sign(year):\n    # Check if the input is a valid year\n    if not isinstance(year, int) or year < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    # Chinese zodiac signs\n    zodiacs = [\"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\", \"Tiger\", \"Hare\"]\n    \n    # Calculate the index based on the year\n    index = year % 12\n    \n    # Return the corresponding zodiac sign\n    return zodiacs[index]",
    "problem": {
      "problem_id": "mbpp_950",
      "question": "Write a function to display sign of the chinese zodiac for given year.",
      "solutions": [
        "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign"
      ],
      "starter_code": "def solution():\n    # Write a function to display sign of the chinese zodiac for given year.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6910000000000001,
    "true_score": 0.6910000000000001,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_950",
    "code": "def chinese_zodiac_sign(year):\n    # Check if the input year is valid\n    if not isinstance(year, int) or year < 0:\n        return \"Invalid input\"\n\n    # Determine the Chinese zodiac sign based on the year\n    if year % 12 == 0:\n        return \"Dragon\"\n    elif year % 12 == 1:\n        return \"Snake\"\n    elif year % 12 == 2:\n        return \"Horse\"\n    elif year % 12 == 3:\n        return \"Goat\"\n    elif year % 12 == 4:\n        return \"Monkey\"\n    elif year % 12 == 5:\n        return \"Rooster\"\n    elif year % 12 == 6:\n        return \"Dog\"\n    elif year % 12 == 7:\n        return \"Pig\"\n    elif year % 12 == 8:\n        return \"Rabbit\"\n    elif year % 12 == 9:\n        return \"Tiger\"\n    elif year % 12 == 10:\n        return \"Hare\"\n    else:\n        return \"Invalid year\"",
    "problem": {
      "problem_id": "mbpp_950",
      "question": "Write a function to display sign of the chinese zodiac for given year.",
      "solutions": [
        "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign"
      ],
      "starter_code": "def solution():\n    # Write a function to display sign of the chinese zodiac for given year.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.686,
    "true_score": 0.686,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_950",
    "code": "def chinese_zodiac_sign(year):\n    if not isinstance(year, int) or year < 0:\n        raise ValueError(\"Year must be a non-negative integer\")\n\n    zodiac_signs = [\"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\", \"Tiger\", \"Hare\", \"Dragon\", \"Snake\", \"Horse\", \"Sheep\"]\n    index = year % 12\n\n    return zodiac_signs[index]",
    "problem": {
      "problem_id": "mbpp_950",
      "question": "Write a function to display sign of the chinese zodiac for given year.",
      "solutions": [
        "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign"
      ],
      "starter_code": "def solution():\n    # Write a function to display sign of the chinese zodiac for given year.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6310000000000001,
    "true_score": 0.6310000000000001,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v5",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v5",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v5",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v5",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v5",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v5",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v5",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v5",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v5",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index, right_index = 0, 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n    \n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n    \n    return merged",
    "problem": {
      "problem_id": "hard_003_v5",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v5",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v5",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v6",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v6",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v6",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v6",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v6",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v6",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v6",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v6",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v6",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v6",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v6",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n    \n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n    \n    return merged",
    "problem": {
      "problem_id": "hard_003_v6",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v7",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v7",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v7",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v7",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v7",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v7",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v7",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v7",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v7",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v7",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v7",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v7",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v8",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v8",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v8",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v8",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v8",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v8",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v8",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index, right_index = 0, 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v8",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v8",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v8",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v8",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged",
    "problem": {
      "problem_id": "hard_003_v8",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/81",
    "code": "def numerical_letter_grade(grades):\n    grade_mapping = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'D-'\n    }\n    \n    letter_grades = []\n    for gpa in grades:\n        if gpa not in grade_mapping:\n            raise ValueError(\"Invalid GPA: {}\".format(gpa))\n        letter_grades.append(grade_mapping[gpa])\n    \n    return letter_grades",
    "problem": {
      "problem_id": "HumanEval/81",
      "question": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "solutions": [
        "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
      ],
      "starter_code": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.5710000000000001,
    "true_score": 0.5710000000000001,
    "generation_temperature": 0.5,
    "solution_length": 23,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/81",
    "code": "def numerical_letter_grade(grades):\n    grade_mapping = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'D-'\n    }\n    \n    letter_grades = []\n    for gpa in grades:\n        if gpa < 0 or gpa > 4.0:\n            raise ValueError(\"GPA must be between 0 and 4.0\")\n        \n        letter_grades.append(grade_mapping[gpa])\n    \n    return letter_grades",
    "problem": {
      "problem_id": "HumanEval/81",
      "question": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "solutions": [
        "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
      ],
      "starter_code": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.5710000000000001,
    "true_score": 0.5710000000000001,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/81",
    "code": "def numerical_letter_grade(grades):\n    grade_mapping = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'D-'\n    }\n    \n    letter_grades = []\n    for gpa in grades:\n        if gpa not in grade_mapping:\n            raise ValueError(\"Invalid GPA\")\n        letter_grades.append(grade_mapping[gpa])\n    \n    return letter_grades",
    "problem": {
      "problem_id": "HumanEval/81",
      "question": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "solutions": [
        "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
      ],
      "starter_code": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.5710000000000001,
    "true_score": 0.5710000000000001,
    "generation_temperature": 0.5,
    "solution_length": 23,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/94",
    "code": "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    max_prime = 0\n    for num in lst:\n        if is_prime(num):\n            max_prime = max(max_prime, num)\n    \n    if max_prime == 0:\n        return 0\n    \n    return sum(int(digit) for digit in str(max_prime))",
    "problem": {
      "problem_id": "HumanEval/94",
      "question": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "solutions": [
        "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"
      ],
      "starter_code": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 19
    },
    "base_score": 0.629,
    "true_score": 0.629,
    "generation_temperature": 0.5,
    "solution_length": 20,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/94",
    "code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    max_prime = 0\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    if max_prime == 0:\n        return 0\n\n    return sum(int(digit) for digit in str(max_prime))",
    "problem": {
      "problem_id": "HumanEval/94",
      "question": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "solutions": [
        "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"
      ],
      "starter_code": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 19
    },
    "base_score": 0.609,
    "true_score": 0.609,
    "generation_temperature": 0.5,
    "solution_length": 18,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/94",
    "code": "from typing import List\n\ndef skjkasdkd(lst: List[int]) -> int:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = 0\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    return sum(int(digit) for digit in str(max_prime))",
    "problem": {
      "problem_id": "HumanEval/94",
      "question": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "solutions": [
        "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"
      ],
      "starter_code": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 19
    },
    "base_score": 0.609,
    "true_score": 0.609,
    "generation_temperature": 0.5,
    "solution_length": 23,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/94",
    "code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = 0\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    if max_prime == 0:\n        return 0\n\n    return sum(int(digit) for digit in str(max_prime))",
    "problem": {
      "problem_id": "HumanEval/94",
      "question": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "solutions": [
        "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"
      ],
      "starter_code": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 19
    },
    "base_score": 0.594,
    "true_score": 0.594,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/94",
    "code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = 0\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    if max_prime == 0:\n        return 0\n\n    return sum(int(digit) for digit in str(max_prime))",
    "problem": {
      "problem_id": "HumanEval/94",
      "question": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "solutions": [
        "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"
      ],
      "starter_code": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 19
    },
    "base_score": 0.594,
    "true_score": 0.594,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/94",
    "code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = 0\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    if max_prime == 0:\n        return 0\n\n    return sum(int(digit) for digit in str(max_prime))",
    "problem": {
      "problem_id": "HumanEval/94",
      "question": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "solutions": [
        "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"
      ],
      "starter_code": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 19
    },
    "base_score": 0.594,
    "true_score": 0.594,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_689",
    "code": "def min_jumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n    \n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] >= i - j:\n                dp[i] = min(dp[i], dp[j] + 1)\n    \n    return dp[-1] if dp[-1] != float('inf') else -1",
    "problem": {
      "problem_id": "mbpp_689",
      "question": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
      "solutions": [
        "def min_jumps(arr, n):\r\n\tjumps = [0 for i in range(n)]\r\n\tif (n == 0) or (arr[0] == 0):\r\n\t\treturn float('inf')\r\n\tjumps[0] = 0\r\n\tfor i in range(1, n):\r\n\t\tjumps[i] = float('inf')\r\n\t\tfor j in range(i):\r\n\t\t\tif (i <= j + arr[j]) and (jumps[j] != float('inf')):\r\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\r\n\t\t\t\tbreak\r\n\treturn jumps[n-1]"
      ],
      "starter_code": "def solution():\n    # ## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.647,
    "true_score": 0.647,
    "generation_temperature": 0.5,
    "solution_length": 14,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_689",
    "code": "def min_jumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n    \n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] >= i - j:\n                dp[i] = min(dp[i], dp[j] + 1)\n    \n    return dp[n-1]",
    "problem": {
      "problem_id": "mbpp_689",
      "question": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
      "solutions": [
        "def min_jumps(arr, n):\r\n\tjumps = [0 for i in range(n)]\r\n\tif (n == 0) or (arr[0] == 0):\r\n\t\treturn float('inf')\r\n\tjumps[0] = 0\r\n\tfor i in range(1, n):\r\n\t\tjumps[i] = float('inf')\r\n\t\tfor j in range(i):\r\n\t\t\tif (i <= j + arr[j]) and (jumps[j] != float('inf')):\r\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\r\n\t\t\t\tbreak\r\n\treturn jumps[n-1]"
      ],
      "starter_code": "def solution():\n    # ## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.612,
    "true_score": 0.612,
    "generation_temperature": 0.5,
    "solution_length": 14,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_689",
    "code": "def min_jumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n    \n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] >= i - j:\n                dp[i] = min(dp[i], dp[j] + 1)\n    \n    return dp[n-1]",
    "problem": {
      "problem_id": "mbpp_689",
      "question": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
      "solutions": [
        "def min_jumps(arr, n):\r\n\tjumps = [0 for i in range(n)]\r\n\tif (n == 0) or (arr[0] == 0):\r\n\t\treturn float('inf')\r\n\tjumps[0] = 0\r\n\tfor i in range(1, n):\r\n\t\tjumps[i] = float('inf')\r\n\t\tfor j in range(i):\r\n\t\t\tif (i <= j + arr[j]) and (jumps[j] != float('inf')):\r\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\r\n\t\t\t\tbreak\r\n\treturn jumps[n-1]"
      ],
      "starter_code": "def solution():\n    # ## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.612,
    "true_score": 0.612,
    "generation_temperature": 0.5,
    "solution_length": 14,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_689",
    "code": "def min_jumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n    \n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] >= i - j:\n                dp[i] = min(dp[i], dp[j] + 1)\n    \n    return dp[n-1]",
    "problem": {
      "problem_id": "mbpp_689",
      "question": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
      "solutions": [
        "def min_jumps(arr, n):\r\n\tjumps = [0 for i in range(n)]\r\n\tif (n == 0) or (arr[0] == 0):\r\n\t\treturn float('inf')\r\n\tjumps[0] = 0\r\n\tfor i in range(1, n):\r\n\t\tjumps[i] = float('inf')\r\n\t\tfor j in range(i):\r\n\t\t\tif (i <= j + arr[j]) and (jumps[j] != float('inf')):\r\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\r\n\t\t\t\tbreak\r\n\treturn jumps[n-1]"
      ],
      "starter_code": "def solution():\n    # ## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.612,
    "true_score": 0.612,
    "generation_temperature": 0.5,
    "solution_length": 14,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_689",
    "code": "def min_jumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n    \n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] >= i - j:\n                dp[i] = min(dp[i], dp[j] + 1)\n    \n    return dp[n-1]",
    "problem": {
      "problem_id": "mbpp_689",
      "question": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
      "solutions": [
        "def min_jumps(arr, n):\r\n\tjumps = [0 for i in range(n)]\r\n\tif (n == 0) or (arr[0] == 0):\r\n\t\treturn float('inf')\r\n\tjumps[0] = 0\r\n\tfor i in range(1, n):\r\n\t\tjumps[i] = float('inf')\r\n\t\tfor j in range(i):\r\n\t\t\tif (i <= j + arr[j]) and (jumps[j] != float('inf')):\r\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\r\n\t\t\t\tbreak\r\n\treturn jumps[n-1]"
      ],
      "starter_code": "def solution():\n    # ## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.612,
    "true_score": 0.612,
    "generation_temperature": 0.5,
    "solution_length": 14,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_689",
    "code": "def min_jumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n    \n    jumps = [float('inf')] * n\n    jumps[0] = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            if arr[j] >= i - j and jumps[j] != float('inf'):\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n    \n    return jumps[n-1]",
    "problem": {
      "problem_id": "mbpp_689",
      "question": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
      "solutions": [
        "def min_jumps(arr, n):\r\n\tjumps = [0 for i in range(n)]\r\n\tif (n == 0) or (arr[0] == 0):\r\n\t\treturn float('inf')\r\n\tjumps[0] = 0\r\n\tfor i in range(1, n):\r\n\t\tjumps[i] = float('inf')\r\n\t\tfor j in range(i):\r\n\t\t\tif (i <= j + arr[j]) and (jumps[j] != float('inf')):\r\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\r\n\t\t\t\tbreak\r\n\treturn jumps[n-1]"
      ],
      "starter_code": "def solution():\n    # ## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5920000000000001,
    "true_score": 0.5920000000000001,
    "generation_temperature": 0.5,
    "solution_length": 14,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/108",
    "code": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    def sum_of_digits(n):\n        if n < 0:\n            n = -n\n            return sum(int(digit) for digit in str(n)[1:])\n        return sum(int(digit) for digit in str(n))\n    \n    return sum(1 for num in arr if sum_of_digits(num) > 0)",
    "problem": {
      "problem_id": "HumanEval/108",
      "question": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "solutions": [
        "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
      ],
      "starter_code": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.74,
    "true_score": 0.74,
    "generation_temperature": 0.5,
    "solution_length": 17,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/108",
    "code": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            while num > 0:\n                count += num % 10\n                num //= 10\n        else:\n            while num > 0:\n                count += num % 10\n                num //= 10\n        if count > 0:\n            count += 1\n    return count",
    "problem": {
      "problem_id": "HumanEval/108",
      "question": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "solutions": [
        "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
      ],
      "starter_code": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.675,
    "true_score": 0.675,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/108",
    "code": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            while num > 0:\n                count += num % 10\n                num //= 10\n        else:\n            while num > 0:\n                count += num % 10\n                num //= 10\n        if count > 0:\n            count += 1\n    return count",
    "problem": {
      "problem_id": "HumanEval/108",
      "question": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "solutions": [
        "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
      ],
      "starter_code": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.675,
    "true_score": 0.675,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/108",
    "code": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            while num > 0:\n                count += num % 10\n                num //= 10\n        else:\n            while num > 0:\n                count += num % 10\n                num //= 10\n        if count > 0:\n            count += 1\n    return count",
    "problem": {
      "problem_id": "HumanEval/108",
      "question": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "solutions": [
        "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
      ],
      "starter_code": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.675,
    "true_score": 0.675,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/108",
    "code": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            while num > 0:\n                count += num % 10\n                num //= 10\n        else:\n            while num > 0:\n                count += num % 10\n                num //= 10\n        if count > 0:\n            count += 1\n    return count",
    "problem": {
      "problem_id": "HumanEval/108",
      "question": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "solutions": [
        "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
      ],
      "starter_code": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.675,
    "true_score": 0.675,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/108",
    "code": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            while num > 0:\n                count += num % 10\n                num //= 10\n        else:\n            while num > 0:\n                count += num % 10\n                num //= 10\n        if count > 0:\n            count += 1\n    return count",
    "problem": {
      "problem_id": "HumanEval/108",
      "question": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "solutions": [
        "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
      ],
      "starter_code": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.675,
    "true_score": 0.675,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_694",
    "code": "def unique_values(dictionary):\n    # Extract unique values from the given dictionary values.\n    unique_values = set(dictionary.values())\n    return list(unique_values)",
    "problem": {
      "problem_id": "mbpp_694",
      "question": "Write a function to extract unique values from the given dictionary values.",
      "solutions": [
        "def extract_unique(test_dict):\r\n  res = list(sorted({ele for val in test_dict.values() for ele in val}))\r\n  return res"
      ],
      "starter_code": "def solution():\n    # Write a function to extract unique values from the given dictionary values.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.73,
    "true_score": 0.73,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_694",
    "code": "def unique_values(dictionary):\n    # Extract unique values from the given dictionary values.\n    unique_values = set(dictionary.values())\n    return list(unique_values)",
    "problem": {
      "problem_id": "mbpp_694",
      "question": "Write a function to extract unique values from the given dictionary values.",
      "solutions": [
        "def extract_unique(test_dict):\r\n  res = list(sorted({ele for val in test_dict.values() for ele in val}))\r\n  return res"
      ],
      "starter_code": "def solution():\n    # Write a function to extract unique values from the given dictionary values.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.73,
    "true_score": 0.73,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_694",
    "code": "def unique_values(dictionary):\n    # Extract unique values from the given dictionary values.\n    unique_values = set(dictionary.values())\n    return list(unique_values)",
    "problem": {
      "problem_id": "mbpp_694",
      "question": "Write a function to extract unique values from the given dictionary values.",
      "solutions": [
        "def extract_unique(test_dict):\r\n  res = list(sorted({ele for val in test_dict.values() for ele in val}))\r\n  return res"
      ],
      "starter_code": "def solution():\n    # Write a function to extract unique values from the given dictionary values.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.73,
    "true_score": 0.73,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_694",
    "code": "def unique_values(dictionary):\n    # Extract unique values from the given dictionary values.\n    unique_values = set(dictionary.values())\n    return list(unique_values)",
    "problem": {
      "problem_id": "mbpp_694",
      "question": "Write a function to extract unique values from the given dictionary values.",
      "solutions": [
        "def extract_unique(test_dict):\r\n  res = list(sorted({ele for val in test_dict.values() for ele in val}))\r\n  return res"
      ],
      "starter_code": "def solution():\n    # Write a function to extract unique values from the given dictionary values.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.73,
    "true_score": 0.73,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_694",
    "code": "def extract_unique_values(dictionary):\n    # Extract unique values from the given dictionary values.\n    unique_values = set(dictionary.values())\n    return list(unique_values)",
    "problem": {
      "problem_id": "mbpp_694",
      "question": "Write a function to extract unique values from the given dictionary values.",
      "solutions": [
        "def extract_unique(test_dict):\r\n  res = list(sorted({ele for val in test_dict.values() for ele in val}))\r\n  return res"
      ],
      "starter_code": "def solution():\n    # Write a function to extract unique values from the given dictionary values.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.73,
    "true_score": 0.73,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_694",
    "code": "from typing import List\n\ndef unique_values(values: List[str]) -> List[str]:\n    unique_values = set(values)\n    return list(unique_values)",
    "problem": {
      "problem_id": "mbpp_694",
      "question": "Write a function to extract unique values from the given dictionary values.",
      "solutions": [
        "def extract_unique(test_dict):\r\n  res = list(sorted({ele for val in test_dict.values() for ele in val}))\r\n  return res"
      ],
      "starter_code": "def solution():\n    # Write a function to extract unique values from the given dictionary values.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.65,
    "true_score": 0.65,
    "generation_temperature": 0.5,
    "solution_length": 5,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_747",
    "code": "from typing import List\n\ndef longest_common_subsequence(str1: str, str2: str, str3: str) -> str:\n    m, n, o = len(str1), len(str2), len(str3)\n    \n    # Create a 3D DP table to store lengths of LCSs\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n    \n    # Reconstruct the LCS from the DP table\n    lcs = []\n    i, j, k = m, n, o\n    while i > 0 and j > 0 and k > 0:\n        if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n            lcs.append(str1[i - 1])\n            i -= 1\n            j -= 1\n            k -= 1\n        elif dp[i - 1][j][k] >= dp[i][j - 1][k] and dp[i - 1][j][k] >= dp[i][j][k - 1]:\n            i -= 1\n        elif dp[i][j - 1][k] >= dp[i - 1][j][k] and dp[i][j - 1][k] >= dp[i][j][k - 1]:\n            j -= 1\n        else:\n            k -= 1\n    \n    return ''.join(reversed(lcs))",
    "problem": {
      "problem_id": "mbpp_747",
      "question": "Write a function to find the longest common subsequence for the given three string sequence.",
      "solutions": [
        "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the longest common subsequence for the given three string sequence.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 34,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_747",
    "code": "def longest_common_subsequence(str1, str2, str3):\n    m = len(str1)\n    n = len(str2)\n    o = len(str3)\n\n    # Create a 3D DP table to store lengths of LCSs\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n\n    # Build the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n\n    # The length of the longest common subsequence is in dp[m][n][o]\n    return dp[m][n][o]",
    "problem": {
      "problem_id": "mbpp_747",
      "question": "Write a function to find the longest common subsequence for the given three string sequence.",
      "solutions": [
        "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the longest common subsequence for the given three string sequence.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.68,
    "true_score": 0.68,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_747",
    "code": "def longest_common_subsequence(str1, str2, str3):\n    m = len(str1)\n    n = len(str2)\n    o = len(str3)\n\n    # Create a 3D DP table to store lengths of LCSs\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n\n    # Build the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n\n    # The length of the longest common subsequence is in dp[m][n][o]\n    return dp[m][n][o]",
    "problem": {
      "problem_id": "mbpp_747",
      "question": "Write a function to find the longest common subsequence for the given three string sequence.",
      "solutions": [
        "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the longest common subsequence for the given three string sequence.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.68,
    "true_score": 0.68,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_747",
    "code": "def longest_common_subsequence(str1, str2, str3):\n    m = len(str1)\n    n = len(str2)\n    o = len(str3)\n\n    # Create a 3D DP table to store lengths of LCSs\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n\n    # Build the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n\n    # The length of the longest common subsequence is in dp[m][n][o]\n    return dp[m][n][o]",
    "problem": {
      "problem_id": "mbpp_747",
      "question": "Write a function to find the longest common subsequence for the given three string sequence.",
      "solutions": [
        "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the longest common subsequence for the given three string sequence.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.68,
    "true_score": 0.68,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_747",
    "code": "def longest_common_subsequence(str1, str2, str3):\n    m, n, o = len(str1), len(str2), len(str3)\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n\n    return dp[m][n][o]",
    "problem": {
      "problem_id": "mbpp_747",
      "question": "Write a function to find the longest common subsequence for the given three string sequence.",
      "solutions": [
        "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the longest common subsequence for the given three string sequence.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.665,
    "true_score": 0.665,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_747",
    "code": "def longest_common_subsequence(str1, str2, str3):\n    m, n, p = len(str1), len(str2), len(str3)\n    dp = [[[0 for _ in range(p + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, p + 1):\n                if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n\n    return dp[m][n][p]",
    "problem": {
      "problem_id": "mbpp_747",
      "question": "Write a function to find the longest common subsequence for the given three string sequence.",
      "solutions": [
        "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the longest common subsequence for the given three string sequence.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.665,
    "true_score": 0.665,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_757",
    "code": "def count_reverse_pairs(str_list):\n    # Count the pairs of reverse strings in the given string list.\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count",
    "problem": {
      "problem_id": "mbpp_757",
      "question": "Write a function to count the pairs of reverse strings in the given string list.",
      "solutions": [
        "def count_reverse_pairs(test_list):\r\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \r\n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \r\n  return str(res)"
      ],
      "starter_code": "def solution():\n    # Write a function to count the pairs of reverse strings in the given string list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6950000000000001,
    "true_score": 0.6950000000000001,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_757",
    "code": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count",
    "problem": {
      "problem_id": "mbpp_757",
      "question": "Write a function to count the pairs of reverse strings in the given string list.",
      "solutions": [
        "def count_reverse_pairs(test_list):\r\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \r\n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \r\n  return str(res)"
      ],
      "starter_code": "def solution():\n    # Write a function to count the pairs of reverse strings in the given string list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.68,
    "true_score": 0.68,
    "generation_temperature": 0.5,
    "solution_length": 7,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_757",
    "code": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count",
    "problem": {
      "problem_id": "mbpp_757",
      "question": "Write a function to count the pairs of reverse strings in the given string list.",
      "solutions": [
        "def count_reverse_pairs(test_list):\r\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \r\n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \r\n  return str(res)"
      ],
      "starter_code": "def solution():\n    # Write a function to count the pairs of reverse strings in the given string list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.68,
    "true_score": 0.68,
    "generation_temperature": 0.5,
    "solution_length": 7,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_757",
    "code": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count",
    "problem": {
      "problem_id": "mbpp_757",
      "question": "Write a function to count the pairs of reverse strings in the given string list.",
      "solutions": [
        "def count_reverse_pairs(test_list):\r\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \r\n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \r\n  return str(res)"
      ],
      "starter_code": "def solution():\n    # Write a function to count the pairs of reverse strings in the given string list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.68,
    "true_score": 0.68,
    "generation_temperature": 0.5,
    "solution_length": 7,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_757",
    "code": "def count_reverse_pairs(strings):\n    count = 0\n    n = len(strings)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count",
    "problem": {
      "problem_id": "mbpp_757",
      "question": "Write a function to count the pairs of reverse strings in the given string list.",
      "solutions": [
        "def count_reverse_pairs(test_list):\r\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \r\n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \r\n  return str(res)"
      ],
      "starter_code": "def solution():\n    # Write a function to count the pairs of reverse strings in the given string list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.68,
    "true_score": 0.68,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_757",
    "code": "from typing import List\n\ndef count_reverse_pairs(strings: List[str]) -> int:\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count",
    "problem": {
      "problem_id": "mbpp_757",
      "question": "Write a function to count the pairs of reverse strings in the given string list.",
      "solutions": [
        "def count_reverse_pairs(test_list):\r\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \r\n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \r\n  return str(res)"
      ],
      "starter_code": "def solution():\n    # Write a function to count the pairs of reverse strings in the given string list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.68,
    "true_score": 0.68,
    "generation_temperature": 0.5,
    "solution_length": 9,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_652",
    "code": "def flatten_tuple_matrix(matrix):\n    \"\"\"\n    Flattens a tuple matrix into a tuple list with each tuple representing each column.\n    \n    Args:\n    matrix (tuple): A tuple of tuples representing the matrix.\n    \n    Returns:\n    tuple: A tuple list where each element is a tuple representing a column.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return ()\n    \n    num_columns = len(matrix[0])\n    flattened_list = []\n    \n    for col_index in range(num_columns):\n        column = tuple(row[col_index] for row in matrix)\n        flattened_list.append(column)\n    \n    return tuple(flattened_list)",
    "problem": {
      "problem_id": "mbpp_652",
      "question": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
      "solutions": [
        "def matrix_to_list(test_list):\r\n  temp = [ele for sub in test_list for ele in sub]\r\n  res = list(zip(*temp))\r\n  return (str(res))"
      ],
      "starter_code": "def solution():\n    # Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.7650000000000001,
    "true_score": 0.7650000000000001,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_652",
    "code": "def flatten_tuple_matrix(matrix):\n    \"\"\"\n    Flattens a tuple matrix into a tuple list with each tuple representing each column.\n    \n    Args:\n    matrix (tuple): A tuple of tuples representing the matrix.\n    \n    Returns:\n    tuple: A tuple list where each element is a tuple representing a column.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return ()\n    \n    num_columns = len(matrix[0])\n    flattened_list = []\n    \n    for col_index in range(num_columns):\n        column = tuple(row[col_index] for row in matrix)\n        flattened_list.append(column)\n    \n    return tuple(flattened_list)",
    "problem": {
      "problem_id": "mbpp_652",
      "question": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
      "solutions": [
        "def matrix_to_list(test_list):\r\n  temp = [ele for sub in test_list for ele in sub]\r\n  res = list(zip(*temp))\r\n  return (str(res))"
      ],
      "starter_code": "def solution():\n    # Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.7650000000000001,
    "true_score": 0.7650000000000001,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_652",
    "code": "def flatten_tuple_matrix(matrix):\n    \"\"\"\n    Flattens a tuple matrix into a tuple list with each tuple representing each column.\n    \n    Args:\n    matrix (tuple): A tuple of tuples representing the matrix.\n    \n    Returns:\n    tuple: A tuple list where each element is a tuple representing a column.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return ()\n    \n    num_columns = len(matrix[0])\n    flattened_list = []\n    \n    for col_index in range(num_columns):\n        column = tuple(row[col_index] for row in matrix)\n        flattened_list.append(column)\n    \n    return tuple(flattened_list)",
    "problem": {
      "problem_id": "mbpp_652",
      "question": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
      "solutions": [
        "def matrix_to_list(test_list):\r\n  temp = [ele for sub in test_list for ele in sub]\r\n  res = list(zip(*temp))\r\n  return (str(res))"
      ],
      "starter_code": "def solution():\n    # Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.7650000000000001,
    "true_score": 0.7650000000000001,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_652",
    "code": "def flatten_tuple_matrix(matrix):\n    \"\"\"\n    Flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    \n    Args:\n    matrix (tuple): A tuple of tuples, where each inner tuple represents a row in the matrix.\n    \n    Returns:\n    tuple: A tuple containing tuples, where each tuple represents a column in the matrix.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return ()\n    \n    num_rows, num_cols = len(matrix), len(matrix[0])\n    flattened_list = []\n    \n    for col_index in range(num_cols):\n        column = tuple(row[col_index] for row in matrix)\n        flattened_list.append(column)\n    \n    return tuple(flattened_list)",
    "problem": {
      "problem_id": "mbpp_652",
      "question": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
      "solutions": [
        "def matrix_to_list(test_list):\r\n  temp = [ele for sub in test_list for ele in sub]\r\n  res = list(zip(*temp))\r\n  return (str(res))"
      ],
      "starter_code": "def solution():\n    # Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.7650000000000001,
    "true_score": 0.7650000000000001,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_652",
    "code": "def flatten_tuple_matrix(matrix):\n    # Flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    flattened_list = []\n    for row in matrix:\n        for item in row:\n            flattened_list.append(item)\n    return tuple(flattened_list)",
    "problem": {
      "problem_id": "mbpp_652",
      "question": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
      "solutions": [
        "def matrix_to_list(test_list):\r\n  temp = [ele for sub in test_list for ele in sub]\r\n  res = list(zip(*temp))\r\n  return (str(res))"
      ],
      "starter_code": "def solution():\n    # Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.7300000000000001,
    "true_score": 0.7300000000000001,
    "generation_temperature": 0.5,
    "solution_length": 7,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_652",
    "code": "def flatten_tuple_matrix(matrix):\n    \"\"\"\n    Flattens a tuple matrix into a list of tuples, where each tuple represents a column.\n    \n    Args:\n    matrix (tuple): A tuple of tuples representing the matrix.\n    \n    Returns:\n    list: A list of tuples, each representing a column of the matrix.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return []\n    \n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n    \n    # Initialize the result list with empty lists for each column\n    result = [[] for _ in range(num_cols)]\n    \n    # Iterate through each row and each element in the row\n    for row in matrix:\n        for i, element in enumerate(row):\n            result[i].append(element)\n    \n    return result",
    "problem": {
      "problem_id": "mbpp_652",
      "question": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
      "solutions": [
        "def matrix_to_list(test_list):\r\n  temp = [ele for sub in test_list for ele in sub]\r\n  res = list(zip(*temp))\r\n  return (str(res))"
      ],
      "starter_code": "def solution():\n    # Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.7050000000000001,
    "true_score": 0.7050000000000001,
    "generation_temperature": 0.5,
    "solution_length": 25,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_920",
    "code": "def remove_none_tuples(tuples_list):\n    # Remove all tuples with all none values in the given tuple list.\n    return [t for t in tuples_list if any(t)]",
    "problem": {
      "problem_id": "mbpp_920",
      "question": "Write a function to remove all tuples with all none values in the given tuple list.",
      "solutions": [
        "def remove_tuple(test_list):\r\n  res = [sub for sub in test_list if not all(ele == None for ele in sub)]\r\n  return (str(res)) "
      ],
      "starter_code": "def solution():\n    # Write a function to remove all tuples with all none values in the given tuple list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.7050000000000001,
    "true_score": 0.7050000000000001,
    "generation_temperature": 0.5,
    "solution_length": 3,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_920",
    "code": "def remove_none_tuples(tuples_list):\n    # Remove all tuples with all none values in the given tuple list.\n    return [t for t in tuples_list if any(t)]",
    "problem": {
      "problem_id": "mbpp_920",
      "question": "Write a function to remove all tuples with all none values in the given tuple list.",
      "solutions": [
        "def remove_tuple(test_list):\r\n  res = [sub for sub in test_list if not all(ele == None for ele in sub)]\r\n  return (str(res)) "
      ],
      "starter_code": "def solution():\n    # Write a function to remove all tuples with all none values in the given tuple list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.7050000000000001,
    "true_score": 0.7050000000000001,
    "generation_temperature": 0.5,
    "solution_length": 3,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_920",
    "code": "def remove_none_tuples(tuples_list):\n    # Remove all tuples with all none values in the given tuple list.\n    return [t for t in tuples_list if any(t)]",
    "problem": {
      "problem_id": "mbpp_920",
      "question": "Write a function to remove all tuples with all none values in the given tuple list.",
      "solutions": [
        "def remove_tuple(test_list):\r\n  res = [sub for sub in test_list if not all(ele == None for ele in sub)]\r\n  return (str(res)) "
      ],
      "starter_code": "def solution():\n    # Write a function to remove all tuples with all none values in the given tuple list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.7050000000000001,
    "true_score": 0.7050000000000001,
    "generation_temperature": 0.5,
    "solution_length": 3,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_920",
    "code": "def remove_all_none_tuples(tuples_list):\n    # Remove all tuples with all none values in the given tuple list.\n    return [t for t in tuples_list if any(t)]",
    "problem": {
      "problem_id": "mbpp_920",
      "question": "Write a function to remove all tuples with all none values in the given tuple list.",
      "solutions": [
        "def remove_tuple(test_list):\r\n  res = [sub for sub in test_list if not all(ele == None for ele in sub)]\r\n  return (str(res)) "
      ],
      "starter_code": "def solution():\n    # Write a function to remove all tuples with all none values in the given tuple list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.7050000000000001,
    "true_score": 0.7050000000000001,
    "generation_temperature": 0.5,
    "solution_length": 3,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_920",
    "code": "from typing import List\n\ndef remove_none_tuples(tuples_list: List[Tuple]) -> List[Tuple]:\n    return [t for t in tuples_list if any(t)]",
    "problem": {
      "problem_id": "mbpp_920",
      "question": "Write a function to remove all tuples with all none values in the given tuple list.",
      "solutions": [
        "def remove_tuple(test_list):\r\n  res = [sub for sub in test_list if not all(ele == None for ele in sub)]\r\n  return (str(res)) "
      ],
      "starter_code": "def solution():\n    # Write a function to remove all tuples with all none values in the given tuple list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.65,
    "true_score": 0.65,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_920",
    "code": "def remove_none_tuples(tuples_list):\n    return [t for t in tuples_list if any(t)]",
    "problem": {
      "problem_id": "mbpp_920",
      "question": "Write a function to remove all tuples with all none values in the given tuple list.",
      "solutions": [
        "def remove_tuple(test_list):\r\n  res = [sub for sub in test_list if not all(ele == None for ele in sub)]\r\n  return (str(res)) "
      ],
      "starter_code": "def solution():\n    # Write a function to remove all tuples with all none values in the given tuple list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6200000000000001,
    "true_score": 0.6200000000000001,
    "generation_temperature": 0.5,
    "solution_length": 2,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v5",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v5",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v5",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v5",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v5",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v5",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v5",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v5",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v5",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v5",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v5",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v5",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v6",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v6",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v6",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v6",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v6",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v6",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v6",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v6",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v6",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v6",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v6",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v6",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v7",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v7",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v7",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v7",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v7",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v7",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v7",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v7",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v7",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                current_node.children[char] = TrieNode()\n            current_node = current_node.children[char]\n        current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        for char in word:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return current_node.is_end_of_word\n\n    def startsWith(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return False\n            current_node = current_node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v7",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v7",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v7",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  }
]