[
  {
    "problem_id": "hard_001_v6",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v6",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v6",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v6",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v6",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v6",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v6",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store nodes to be processed\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v6",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v6",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances dictionary with infinity for all nodes except the start node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v6",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v6",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances dictionary with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v6",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v7",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v7",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v7",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v7",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v7",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v7",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v7",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    import heapq\n    \n    # Initialize distances dictionary with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store nodes to be processed\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v7",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 29,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v7",
    "code": "from typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    import heapq\n    \n    # Initialize distances with infinity\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v7",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.67,
    "true_score": 0.67,
    "generation_temperature": 0.5,
    "solution_length": 29,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v7",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v7",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.658,
    "true_score": 0.658,
    "generation_temperature": 0.5,
    "solution_length": 22,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v8",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v8",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v8",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v8",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v8",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v8",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v8",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v8",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v8",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity except for the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store (distance, node)\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v8",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_001_v8",
    "code": "import heapq\nfrom typing import Dict, List, Tuple\n\ndef dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n    # Initialize distances with infinity for all nodes except the start node\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    \n    # Priority queue to store nodes to explore\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # Nodes can get added to the priority queue multiple times. We only\n        # process a vertex the first time we remove it from the priority queue.\n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            # Only consider this new path if it's better\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances",
    "problem": {
      "problem_id": "hard_001_v8",
      "question": "Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.",
      "solutions": [
        "def dijkstra(graph, start):\n    import heapq\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        if current_dist > distances[current]:\n            continue\n        for neighbor, weight in graph[current]:\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    return distances"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement Dijkstra's shortest path algorithm for a weighted graph.\n\nFunction signature: def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]:\n\nReturn distances from start to all nodes.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_0\"]"
        ],
        "outputs": [
          "\"test_output_hard_0\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 28,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/129",
    "code": "def minPath(grid, k):\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def dfs(x, y, path):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                dfs(nx, ny, path + [grid[nx][ny]])\n    \n    paths = []\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    \n    return min(paths)",
    "problem": {
      "problem_id": "HumanEval/129",
      "question": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "solutions": [
        "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"
      ],
      "starter_code": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 12
    },
    "base_score": 0.673,
    "true_score": 0.673,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/129",
    "code": "def minPath(grid, k):\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def dfs(x, y, path):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                dfs(nx, ny, path + [grid[nx][ny]])\n    \n    paths = []\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    \n    return min(paths)",
    "problem": {
      "problem_id": "HumanEval/129",
      "question": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "solutions": [
        "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"
      ],
      "starter_code": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 12
    },
    "base_score": 0.673,
    "true_score": 0.673,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/129",
    "code": "def minPath(grid, k):\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def dfs(x, y, path):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                dfs(nx, ny, path + [grid[nx][ny]])\n    \n    paths = []\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    \n    return min(paths)",
    "problem": {
      "problem_id": "HumanEval/129",
      "question": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "solutions": [
        "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"
      ],
      "starter_code": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 12
    },
    "base_score": 0.673,
    "true_score": 0.673,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/129",
    "code": "def minPath(grid, k):\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def dfs(x, y, path):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                dfs(nx, ny, path + [grid[nx][ny]])\n    \n    paths = []\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    \n    return min(paths)",
    "problem": {
      "problem_id": "HumanEval/129",
      "question": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "solutions": [
        "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"
      ],
      "starter_code": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 12
    },
    "base_score": 0.673,
    "true_score": 0.673,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/129",
    "code": "def minPath(grid, k):\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def dfs(x, y, path):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                dfs(nx, ny, path + [grid[nx][ny]])\n    \n    paths = []\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    \n    return min(paths)",
    "problem": {
      "problem_id": "HumanEval/129",
      "question": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "solutions": [
        "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"
      ],
      "starter_code": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 12
    },
    "base_score": 0.673,
    "true_score": 0.673,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/129",
    "code": "def minPath(grid, k):\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def dfs(x, y, path):\n        if len(path) == k:\n            paths.append(path[:])\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                dfs(nx, ny, path + [grid[nx][ny]])\n    \n    paths = []\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]])\n    \n    return min(paths)",
    "problem": {
      "problem_id": "HumanEval/129",
      "question": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "solutions": [
        "    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"
      ],
      "starter_code": "\ndef minPath(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 12
    },
    "base_score": 0.673,
    "true_score": 0.673,
    "generation_temperature": 0.5,
    "solution_length": 19,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_974",
    "code": "def minimum_total_path_sum(triangle):\n    if not triangle or not triangle[0]:\n        return 0\n    \n    rows = len(triangle)\n    dp = triangle[-1].copy()\n    \n    for row in range(rows-2, -1, -1):\n        for col in range(len(triangle[row])):\n            dp[col] = min(dp[col], dp[col+1]) + triangle[row][col]\n    \n    return dp[0]",
    "problem": {
      "problem_id": "mbpp_974",
      "question": "Write a function to find the minimum total path sum in the given triangle.",
      "solutions": [
        "def min_sum_path(A): \r\n\tmemo = [None] * len(A) \r\n\tn = len(A) - 1\r\n\tfor i in range(len(A[n])): \r\n\t\tmemo[i] = A[n][i] \r\n\tfor i in range(len(A) - 2, -1,-1): \r\n\t\tfor j in range( len(A[i])): \r\n\t\t\tmemo[j] = A[i][j] + min(memo[j], \r\n\t\t\t\t\t\t\t\t\tmemo[j + 1]) \r\n\treturn memo[0]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the minimum total path sum in the given triangle.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6859999999999999,
    "true_score": 0.6859999999999999,
    "generation_temperature": 0.5,
    "solution_length": 12,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_974",
    "code": "def minimum_total_path_sum(triangle):\n    if not triangle or not triangle[0]:\n        return 0\n    \n    rows = len(triangle)\n    dp = triangle[-1].copy()\n    \n    for row in range(rows-2, -1, -1):\n        for col in range(len(triangle[row])):\n            dp[col] = min(dp[col], dp[col+1]) + triangle[row][col]\n    \n    return dp[0]",
    "problem": {
      "problem_id": "mbpp_974",
      "question": "Write a function to find the minimum total path sum in the given triangle.",
      "solutions": [
        "def min_sum_path(A): \r\n\tmemo = [None] * len(A) \r\n\tn = len(A) - 1\r\n\tfor i in range(len(A[n])): \r\n\t\tmemo[i] = A[n][i] \r\n\tfor i in range(len(A) - 2, -1,-1): \r\n\t\tfor j in range( len(A[i])): \r\n\t\t\tmemo[j] = A[i][j] + min(memo[j], \r\n\t\t\t\t\t\t\t\t\tmemo[j + 1]) \r\n\treturn memo[0]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the minimum total path sum in the given triangle.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6859999999999999,
    "true_score": 0.6859999999999999,
    "generation_temperature": 0.5,
    "solution_length": 12,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_974",
    "code": "def minimum_total_path_sum(triangle):\n    if not triangle or not triangle[0]:\n        return 0\n    \n    rows = len(triangle)\n    dp = triangle[-1].copy()\n    \n    for row in range(rows-2, -1, -1):\n        for col in range(len(triangle[row])):\n            dp[col] = min(dp[col], dp[col+1]) + triangle[row][col]\n    \n    return dp[0]",
    "problem": {
      "problem_id": "mbpp_974",
      "question": "Write a function to find the minimum total path sum in the given triangle.",
      "solutions": [
        "def min_sum_path(A): \r\n\tmemo = [None] * len(A) \r\n\tn = len(A) - 1\r\n\tfor i in range(len(A[n])): \r\n\t\tmemo[i] = A[n][i] \r\n\tfor i in range(len(A) - 2, -1,-1): \r\n\t\tfor j in range( len(A[i])): \r\n\t\t\tmemo[j] = A[i][j] + min(memo[j], \r\n\t\t\t\t\t\t\t\t\tmemo[j + 1]) \r\n\treturn memo[0]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the minimum total path sum in the given triangle.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6859999999999999,
    "true_score": 0.6859999999999999,
    "generation_temperature": 0.5,
    "solution_length": 12,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_974",
    "code": "def minimum_total_path_sum(triangle):\n    if not triangle or not triangle[0]:\n        return 0\n    \n    rows = len(triangle)\n    dp = triangle[-1][:]\n    \n    for row in range(rows-2, -1, -1):\n        for col in range(len(triangle[row])):\n            dp[col] = min(dp[col], dp[col+1]) + triangle[row][col]\n    \n    return dp[0]",
    "problem": {
      "problem_id": "mbpp_974",
      "question": "Write a function to find the minimum total path sum in the given triangle.",
      "solutions": [
        "def min_sum_path(A): \r\n\tmemo = [None] * len(A) \r\n\tn = len(A) - 1\r\n\tfor i in range(len(A[n])): \r\n\t\tmemo[i] = A[n][i] \r\n\tfor i in range(len(A) - 2, -1,-1): \r\n\t\tfor j in range( len(A[i])): \r\n\t\t\tmemo[j] = A[i][j] + min(memo[j], \r\n\t\t\t\t\t\t\t\t\tmemo[j + 1]) \r\n\treturn memo[0]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the minimum total path sum in the given triangle.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6859999999999999,
    "true_score": 0.6859999999999999,
    "generation_temperature": 0.5,
    "solution_length": 12,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_974",
    "code": "def solution(triangle):\n    if not triangle or not triangle[0]:\n        return 0\n    \n    n = len(triangle)\n    dp = triangle[-1][:]\n    \n    for i in range(n-2, -1, -1):\n        for j in range(len(triangle[i])):\n            dp[j] = min(dp[j], dp[j+1]) + triangle[i][j]\n    \n    return dp[0]",
    "problem": {
      "problem_id": "mbpp_974",
      "question": "Write a function to find the minimum total path sum in the given triangle.",
      "solutions": [
        "def min_sum_path(A): \r\n\tmemo = [None] * len(A) \r\n\tn = len(A) - 1\r\n\tfor i in range(len(A[n])): \r\n\t\tmemo[i] = A[n][i] \r\n\tfor i in range(len(A) - 2, -1,-1): \r\n\t\tfor j in range( len(A[i])): \r\n\t\t\tmemo[j] = A[i][j] + min(memo[j], \r\n\t\t\t\t\t\t\t\t\tmemo[j + 1]) \r\n\treturn memo[0]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the minimum total path sum in the given triangle.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5740000000000001,
    "true_score": 0.5740000000000001,
    "generation_temperature": 0.5,
    "solution_length": 12,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_974",
    "code": "def solution(triangle):\n    n = len(triangle)\n    for i in range(n-2, -1, -1):\n        for j in range(i+1):\n            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])\n    return triangle[0][0]",
    "problem": {
      "problem_id": "mbpp_974",
      "question": "Write a function to find the minimum total path sum in the given triangle.",
      "solutions": [
        "def min_sum_path(A): \r\n\tmemo = [None] * len(A) \r\n\tn = len(A) - 1\r\n\tfor i in range(len(A[n])): \r\n\t\tmemo[i] = A[n][i] \r\n\tfor i in range(len(A) - 2, -1,-1): \r\n\t\tfor j in range( len(A[i])): \r\n\t\t\tmemo[j] = A[i][j] + min(memo[j], \r\n\t\t\t\t\t\t\t\t\tmemo[j + 1]) \r\n\treturn memo[0]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the minimum total path sum in the given triangle.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.554,
    "true_score": 0.554,
    "generation_temperature": 0.5,
    "solution_length": 6,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_721",
    "code": "def solution(matrix):\n    n = len(matrix)\n    if n == 0:\n        return 0\n    \n    max_average = float('-inf')\n    \n    for i in range(n):\n        for j in range(n):\n            current_sum = 0\n            count = 0\n            for k in range(i, n):\n                for l in range(j, n):\n                    current_sum += matrix[k][l]\n                    count += 1\n                    max_average = max(max_average, current_sum / count)\n    \n    return max_average",
    "problem": {
      "problem_id": "mbpp_721",
      "question": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
      "solutions": [
        "M = 100\r\ndef maxAverageOfPath(cost, N): \r\n\tdp = [[0 for i in range(N + 1)] for j in range(N + 1)] \r\n\tdp[0][0] = cost[0][0] \r\n\tfor i in range(1, N): \r\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0] \r\n\tfor j in range(1, N): \r\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j] \r\n\tfor i in range(1, N): \r\n\t\tfor j in range(1, N): \r\n\t\t\tdp[i][j] = max(dp[i - 1][j], \r\n\t\t\t\t\t\tdp[i][j - 1]) + cost[i][j] \r\n\treturn dp[N - 1][N - 1] / (2 * N - 1)"
      ],
      "starter_code": "def solution():\n    # Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5690000000000001,
    "true_score": 0.5690000000000001,
    "generation_temperature": 0.5,
    "solution_length": 18,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_721",
    "code": "def solution(matrix):\n    n = len(matrix)\n    if n == 0:\n        return 0\n    \n    max_average = float('-inf')\n    \n    for i in range(n):\n        for j in range(n):\n            current_sum = 0\n            count = 0\n            for k in range(i, n):\n                for l in range(j, n):\n                    current_sum += matrix[k][l]\n                    count += 1\n                    max_average = max(max_average, current_sum / count)\n    \n    return max_average",
    "problem": {
      "problem_id": "mbpp_721",
      "question": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
      "solutions": [
        "M = 100\r\ndef maxAverageOfPath(cost, N): \r\n\tdp = [[0 for i in range(N + 1)] for j in range(N + 1)] \r\n\tdp[0][0] = cost[0][0] \r\n\tfor i in range(1, N): \r\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0] \r\n\tfor j in range(1, N): \r\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j] \r\n\tfor i in range(1, N): \r\n\t\tfor j in range(1, N): \r\n\t\t\tdp[i][j] = max(dp[i - 1][j], \r\n\t\t\t\t\t\tdp[i][j - 1]) + cost[i][j] \r\n\treturn dp[N - 1][N - 1] / (2 * N - 1)"
      ],
      "starter_code": "def solution():\n    # Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5690000000000001,
    "true_score": 0.5690000000000001,
    "generation_temperature": 0.5,
    "solution_length": 18,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_721",
    "code": "def solution(matrix):\n    n = len(matrix)\n    if n == 0:\n        return 0\n    \n    max_average = float('-inf')\n    \n    for i in range(n):\n        for j in range(n):\n            current_sum = 0\n            count = 0\n            for k in range(i, n):\n                for l in range(j, n):\n                    current_sum += matrix[k][l]\n                    count += 1\n                    max_average = max(max_average, current_sum / count)\n    \n    return max_average",
    "problem": {
      "problem_id": "mbpp_721",
      "question": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
      "solutions": [
        "M = 100\r\ndef maxAverageOfPath(cost, N): \r\n\tdp = [[0 for i in range(N + 1)] for j in range(N + 1)] \r\n\tdp[0][0] = cost[0][0] \r\n\tfor i in range(1, N): \r\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0] \r\n\tfor j in range(1, N): \r\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j] \r\n\tfor i in range(1, N): \r\n\t\tfor j in range(1, N): \r\n\t\t\tdp[i][j] = max(dp[i - 1][j], \r\n\t\t\t\t\t\tdp[i][j - 1]) + cost[i][j] \r\n\treturn dp[N - 1][N - 1] / (2 * N - 1)"
      ],
      "starter_code": "def solution():\n    # Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5690000000000001,
    "true_score": 0.5690000000000001,
    "generation_temperature": 0.5,
    "solution_length": 18,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_721",
    "code": "def solution(matrix):\n    n = len(matrix)\n    if n == 0:\n        return 0\n    \n    max_average = float('-inf')\n    \n    for i in range(n):\n        for j in range(n):\n            current_sum = 0\n            count = 0\n            for x in range(i, n):\n                for y in range(j, n):\n                    current_sum += matrix[x][y]\n                    count += 1\n                    max_average = max(max_average, current_sum / count)\n    \n    return max_average",
    "problem": {
      "problem_id": "mbpp_721",
      "question": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
      "solutions": [
        "M = 100\r\ndef maxAverageOfPath(cost, N): \r\n\tdp = [[0 for i in range(N + 1)] for j in range(N + 1)] \r\n\tdp[0][0] = cost[0][0] \r\n\tfor i in range(1, N): \r\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0] \r\n\tfor j in range(1, N): \r\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j] \r\n\tfor i in range(1, N): \r\n\t\tfor j in range(1, N): \r\n\t\t\tdp[i][j] = max(dp[i - 1][j], \r\n\t\t\t\t\t\tdp[i][j - 1]) + cost[i][j] \r\n\treturn dp[N - 1][N - 1] / (2 * N - 1)"
      ],
      "starter_code": "def solution():\n    # Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5690000000000001,
    "true_score": 0.5690000000000001,
    "generation_temperature": 0.5,
    "solution_length": 18,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_721",
    "code": "def solution(matrix):\n    n = len(matrix)\n    \n    def get_neighbors(x, y):\n        neighbors = []\n        if x > 0:\n            neighbors.append((x-1, y))\n        if x < n-1:\n            neighbors.append((x+1, y))\n        if y > 0:\n            neighbors.append((x, y-1))\n        if y < n-1:\n            neighbors.append((x, y+1))\n        return neighbors\n    \n    def dfs(x, y, path_sum, path_length):\n        nonlocal max_avg\n        path_sum += matrix[x][y]\n        path_length += 1\n        avg = path_sum / path_length\n        if avg > max_avg:\n            max_avg = avg\n        \n        for nx, ny in get_neighbors(x, y):\n            dfs(nx, ny, path_sum, path_length)\n    \n    max_avg = float('-inf')\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, 0, 0)\n    \n    return max_avg",
    "problem": {
      "problem_id": "mbpp_721",
      "question": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
      "solutions": [
        "M = 100\r\ndef maxAverageOfPath(cost, N): \r\n\tdp = [[0 for i in range(N + 1)] for j in range(N + 1)] \r\n\tdp[0][0] = cost[0][0] \r\n\tfor i in range(1, N): \r\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0] \r\n\tfor j in range(1, N): \r\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j] \r\n\tfor i in range(1, N): \r\n\t\tfor j in range(1, N): \r\n\t\t\tdp[i][j] = max(dp[i - 1][j], \r\n\t\t\t\t\t\tdp[i][j - 1]) + cost[i][j] \r\n\treturn dp[N - 1][N - 1] / (2 * N - 1)"
      ],
      "starter_code": "def solution():\n    # Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.549,
    "true_score": 0.549,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_721",
    "code": "def solution(matrix):\n    n = len(matrix)\n    if n == 0:\n        return 0\n    \n    max_avg = float('-inf')\n    \n    for i in range(n):\n        for j in range(n):\n            current_sum = 0\n            count = 0\n            for k in range(i, n):\n                for l in range(j, n):\n                    current_sum += matrix[k][l]\n                    count += 1\n                    max_avg = max(max_avg, current_sum / count)\n    \n    return max_avg",
    "problem": {
      "problem_id": "mbpp_721",
      "question": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.",
      "solutions": [
        "M = 100\r\ndef maxAverageOfPath(cost, N): \r\n\tdp = [[0 for i in range(N + 1)] for j in range(N + 1)] \r\n\tdp[0][0] = cost[0][0] \r\n\tfor i in range(1, N): \r\n\t\tdp[i][0] = dp[i - 1][0] + cost[i][0] \r\n\tfor j in range(1, N): \r\n\t\tdp[0][j] = dp[0][j - 1] + cost[0][j] \r\n\tfor i in range(1, N): \r\n\t\tfor j in range(1, N): \r\n\t\t\tdp[i][j] = max(dp[i - 1][j], \r\n\t\t\t\t\t\tdp[i][j - 1]) + cost[i][j] \r\n\treturn dp[N - 1][N - 1] / (2 * N - 1)"
      ],
      "starter_code": "def solution():\n    # Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.542,
    "true_score": 0.542,
    "generation_temperature": 0.5,
    "solution_length": 18,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/6",
    "code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def max_depth(s: str) -> int:\n        depth = max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n\n    return [max_depth(group) for group in paren_string.split()]",
    "problem": {
      "problem_id": "HumanEval/6",
      "question": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "solutions": [
        "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
      ],
      "starter_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 4
    },
    "base_score": 0.687,
    "true_score": 0.687,
    "generation_temperature": 0.5,
    "solution_length": 15,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/6",
    "code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def max_depth(s: str) -> int:\n        depth = max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n\n    return [max_depth(group) for group in paren_string.split()]",
    "problem": {
      "problem_id": "HumanEval/6",
      "question": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "solutions": [
        "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
      ],
      "starter_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 4
    },
    "base_score": 0.687,
    "true_score": 0.687,
    "generation_temperature": 0.5,
    "solution_length": 15,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/6",
    "code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def max_depth(s: str) -> int:\n        depth = max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n\n    return [max_depth(group) for group in paren_string.split()]",
    "problem": {
      "problem_id": "HumanEval/6",
      "question": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "solutions": [
        "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
      ],
      "starter_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 4
    },
    "base_score": 0.687,
    "true_score": 0.687,
    "generation_temperature": 0.5,
    "solution_length": 15,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/6",
    "code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def max_depth(s: str) -> int:\n        depth = max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n\n    return [max_depth(group) for group in paren_string.split()]",
    "problem": {
      "problem_id": "HumanEval/6",
      "question": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "solutions": [
        "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
      ],
      "starter_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 4
    },
    "base_score": 0.687,
    "true_score": 0.687,
    "generation_temperature": 0.5,
    "solution_length": 15,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/6",
    "code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    def max_depth(s: str) -> int:\n        depth = max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n\n    return [max_depth(group) for group in paren_string.split()]",
    "problem": {
      "problem_id": "HumanEval/6",
      "question": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "solutions": [
        "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
      ],
      "starter_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 4
    },
    "base_score": 0.687,
    "true_score": 0.687,
    "generation_temperature": 0.5,
    "solution_length": 15,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/6",
    "code": "def parse_nested_parens(paren_string: str) -> List[int]:\n    def max_depth(s: str) -> int:\n        depth = max_depth = 0\n        for char in s:\n            if char == '(':\n                depth += 1\n                max_depth = max(max_depth, depth)\n            elif char == ')':\n                depth -= 1\n        return max_depth\n\n    return [max_depth(group) for group in paren_string.split()]",
    "problem": {
      "problem_id": "HumanEval/6",
      "question": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "solutions": [
        "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n"
      ],
      "starter_code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 4
    },
    "base_score": 0.651,
    "true_score": 0.651,
    "generation_temperature": 0.5,
    "solution_length": 12,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v0",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            sorted_array.append(left[i])\n            i += 1\n        else:\n            sorted_array.append(right[j])\n            j += 1\n    \n    sorted_array.extend(left[i:])\n    sorted_array.extend(right[j:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v0",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v0",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v0",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v0",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v0",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v0",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v0",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v0",
    "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr",
    "problem": {
      "problem_id": "hard_003_v0",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.585,
    "true_score": 0.585,
    "generation_temperature": 0.5,
    "solution_length": 31,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v0",
    "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr",
    "problem": {
      "problem_id": "hard_003_v0",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.585,
    "true_score": 0.585,
    "generation_temperature": 0.5,
    "solution_length": 31,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v1",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    # Find the middle point to divide the array into two halves\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    # Merge the sorted halves\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    # Merge the two arrays by comparing their elements\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    # Append any remaining elements from either left or right array\n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v1",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 31,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v1",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    # Find the middle point to divide the array into two halves\n    mid = len(arr) // 2\n    \n    # Recursively sort both halves\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    # Merge the sorted halves\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    # Merge the two arrays by comparing their elements\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    # If there are remaining elements in left or right, append them\n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v1",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 33,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v1",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v1",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v1",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v1",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v1",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v1",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v1",
    "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr",
    "problem": {
      "problem_id": "hard_003_v1",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.585,
    "true_score": 0.585,
    "generation_temperature": 0.5,
    "solution_length": 31,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v2",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            sorted_array.append(left[i])\n            i += 1\n        else:\n            sorted_array.append(right[j])\n            j += 1\n    \n    sorted_array.extend(left[i:])\n    sorted_array.extend(right[j:])\n    \n    return sorted_array\n\n# Example usage:\n# input_list = [38, 27, 43, 3, 9, 82, 10]\n# print(merge_sort(input_list))  # Output: [3, 9, 10, 27, 38, 43, 82]",
    "problem": {
      "problem_id": "hard_003_v2",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.64,
    "true_score": 0.64,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v2",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v2",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v2",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v2",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v2",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v2",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v2",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v2",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v2",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v2",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v3",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v3",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v3",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v3",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v3",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v3",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v3",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v3",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v3",
    "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr",
    "problem": {
      "problem_id": "hard_003_v3",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.585,
    "true_score": 0.585,
    "generation_temperature": 0.5,
    "solution_length": 31,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v3",
    "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr",
    "problem": {
      "problem_id": "hard_003_v3",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.585,
    "true_score": 0.585,
    "generation_temperature": 0.5,
    "solution_length": 31,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v4",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v4",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v4",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v4",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v4",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v4",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v4",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v4",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v4",
    "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr",
    "problem": {
      "problem_id": "hard_003_v4",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.585,
    "true_score": 0.585,
    "generation_temperature": 0.5,
    "solution_length": 31,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v4",
    "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr",
    "problem": {
      "problem_id": "hard_003_v4",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.585,
    "true_score": 0.585,
    "generation_temperature": 0.5,
    "solution_length": 31,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/95",
    "code": "def check_dict_case(dictionary):\n    if not dictionary:\n        return False\n    \n    keys = list(dictionary.keys())\n    all_lower = all(key.islower() for key in keys if isinstance(key, str))\n    all_upper = all(key.isupper() for key in keys if isinstance(key, str))\n    \n    return all_lower or all_upper",
    "problem": {
      "problem_id": "HumanEval/95",
      "question": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "solutions": [
        "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
      ],
      "starter_code": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.7190000000000001,
    "true_score": 0.7190000000000001,
    "generation_temperature": 0.5,
    "solution_length": 9,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/95",
    "code": "def check_dict_case(dictionary):\n    if not dictionary:\n        return False\n    \n    all_lower = all(key.islower() for key in dictionary if isinstance(key, str))\n    all_upper = all(key.isupper() for key in dictionary if isinstance(key, str))\n    \n    return all_lower or all_upper",
    "problem": {
      "problem_id": "HumanEval/95",
      "question": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "solutions": [
        "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
      ],
      "starter_code": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.67,
    "true_score": 0.67,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/95",
    "code": "def check_dict_case(dictionary):\n    if not dictionary:\n        return False\n    \n    all_lower = all(key.islower() for key in dictionary if isinstance(key, str))\n    all_upper = all(key.isupper() for key in dictionary if isinstance(key, str))\n    \n    return all_lower or all_upper",
    "problem": {
      "problem_id": "HumanEval/95",
      "question": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "solutions": [
        "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
      ],
      "starter_code": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.67,
    "true_score": 0.67,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/95",
    "code": "def check_dict_case(dictionary):\n    if not dictionary:\n        return False\n    \n    all_lower = all(key.islower() for key in dictionary if isinstance(key, str))\n    all_upper = all(key.isupper() for key in dictionary if isinstance(key, str))\n    \n    return all_lower or all_upper",
    "problem": {
      "problem_id": "HumanEval/95",
      "question": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "solutions": [
        "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
      ],
      "starter_code": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.67,
    "true_score": 0.67,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/95",
    "code": "def check_dict_case(dictionary):\n    if not dictionary:\n        return False\n    \n    all_lower = all(key.islower() for key in dictionary if isinstance(key, str))\n    all_upper = all(key.isupper() for key in dictionary if isinstance(key, str))\n    \n    return all_lower or all_upper",
    "problem": {
      "problem_id": "HumanEval/95",
      "question": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "solutions": [
        "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
      ],
      "starter_code": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.67,
    "true_score": 0.67,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/95",
    "code": "def check_dict_case(dictionary):\n    if not dictionary:\n        return False\n\n    all_lower = all(key.islower() for key in dictionary if isinstance(key, str))\n    all_upper = all(key.isupper() for key in dictionary if isinstance(key, str))\n\n    return all_lower or all_upper",
    "problem": {
      "problem_id": "HumanEval/95",
      "question": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "solutions": [
        "    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"
      ],
      "starter_code": "\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.67,
    "true_score": 0.67,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/59",
    "code": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = max(largest_factor, i)\n            if is_prime(n // i):\n                largest_factor = max(largest_factor, n // i)\n    return largest_factor",
    "problem": {
      "problem_id": "HumanEval/59",
      "question": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
      ],
      "starter_code": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 6
    },
    "base_score": 0.701,
    "true_score": 0.701,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/59",
    "code": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 1:\n        largest_factor = n\n    return largest_factor",
    "problem": {
      "problem_id": "HumanEval/59",
      "question": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
      ],
      "starter_code": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 6
    },
    "base_score": 0.681,
    "true_score": 0.681,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/59",
    "code": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 1:\n        largest_factor = n\n    return largest_factor",
    "problem": {
      "problem_id": "HumanEval/59",
      "question": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
      ],
      "starter_code": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 6
    },
    "base_score": 0.681,
    "true_score": 0.681,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/59",
    "code": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 1:\n        largest_factor = n\n    return largest_factor",
    "problem": {
      "problem_id": "HumanEval/59",
      "question": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
      ],
      "starter_code": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 6
    },
    "base_score": 0.681,
    "true_score": 0.681,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/59",
    "code": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n ** 0.5) + 1):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 1:\n        largest_factor = n\n    return largest_factor",
    "problem": {
      "problem_id": "HumanEval/59",
      "question": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
      ],
      "starter_code": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 6
    },
    "base_score": 0.681,
    "true_score": 0.681,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/59",
    "code": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n**0.5) + 1):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 1:\n        largest_factor = n\n    return largest_factor",
    "problem": {
      "problem_id": "HumanEval/59",
      "question": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n"
      ],
      "starter_code": "\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 6
    },
    "base_score": 0.681,
    "true_score": 0.681,
    "generation_temperature": 0.5,
    "solution_length": 24,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/75",
    "code": "def is_multiply_prime(a):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    if a < 2:\n        return False\n\n    prime_factors = 0\n    for i in range(2, a + 1):\n        if a % i == 0 and is_prime(i):\n            prime_factors += 1\n            while a % i == 0:\n                a //= i\n\n    return prime_factors == 3",
    "problem": {
      "problem_id": "HumanEval/75",
      "question": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
      ],
      "starter_code": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.6130000000000001,
    "true_score": 0.6130000000000001,
    "generation_temperature": 0.5,
    "solution_length": 20,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/75",
    "code": "def is_multiply_prime(a):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    if a < 2:\n        return False\n\n    prime_factors = 0\n    for i in range(2, a + 1):\n        while a % i == 0 and is_prime(i):\n            prime_factors += 1\n            a //= i\n        if prime_factors > 3:\n            return False\n\n    return prime_factors == 3",
    "problem": {
      "problem_id": "HumanEval/75",
      "question": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
      ],
      "starter_code": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.6130000000000001,
    "true_score": 0.6130000000000001,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/75",
    "code": "def is_multiply_prime(a):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    if a < 2:\n        return False\n\n    prime_factors = 0\n    for i in range(2, a + 1):\n        if a % i == 0 and is_prime(i):\n            prime_factors += 1\n            while a % i == 0:\n                a //= i\n\n    return prime_factors == 3",
    "problem": {
      "problem_id": "HumanEval/75",
      "question": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
      ],
      "starter_code": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.5980000000000001,
    "true_score": 0.5980000000000001,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/75",
    "code": "def is_multiply_prime(a):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    if a < 2:\n        return False\n\n    prime_factors = 0\n    for i in range(2, a + 1):\n        if a % i == 0 and is_prime(i):\n            prime_factors += 1\n            while a % i == 0:\n                a //= i\n\n    return prime_factors == 3",
    "problem": {
      "problem_id": "HumanEval/75",
      "question": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
      ],
      "starter_code": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.5980000000000001,
    "true_score": 0.5980000000000001,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/75",
    "code": "def is_multiply_prime(a):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    if a < 2:\n        return False\n\n    prime_factors = 0\n    for i in range(2, a + 1):\n        if a % i == 0 and is_prime(i):\n            prime_factors += 1\n            while a % i == 0:\n                a //= i\n\n    return prime_factors == 3",
    "problem": {
      "problem_id": "HumanEval/75",
      "question": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
      ],
      "starter_code": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.5980000000000001,
    "true_score": 0.5980000000000001,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/75",
    "code": "def is_multiply_prime(a):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    if a < 2:\n        return False\n\n    prime_factors = 0\n    for i in range(2, a + 1):\n        if a % i == 0 and is_prime(i):\n            prime_factors += 1\n            while a % i == 0:\n                a //= i\n\n    return prime_factors == 3",
    "problem": {
      "problem_id": "HumanEval/75",
      "question": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "solutions": [
        "    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n"
      ],
      "starter_code": "\ndef is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.5980000000000001,
    "true_score": 0.5980000000000001,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v0",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v0",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v0",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v0",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v0",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v0",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v0",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v0",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v0",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v0",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v0",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v0",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v1",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v1",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v1",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v1",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v1",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v1",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v1",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v1",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v1",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v1",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v1",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v1",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v2",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v2",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v2",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v2",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v2",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v2",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v2",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v2",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v2",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v2",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v2",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v2",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v3",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v3",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v3",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v3",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v3",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v3",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v3",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v3",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v3",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v3",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v3",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v3",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v4",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v4",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v4",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v4",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v4",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v4",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v4",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v4",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v4",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v4",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v4",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v4",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_859",
    "code": "def generate_sublists(lst):\n    def backtrack(start, path):\n        yield path\n        for i in range(start, len(lst)):\n            yield from backtrack(i + 1, path + [lst[i]])\n    \n    return list(backtrack(0, []))",
    "problem": {
      "problem_id": "mbpp_859",
      "question": "Write a function to generate all sublists of a given list.",
      "solutions": [
        "from itertools import combinations\r\ndef sub_lists(my_list):\r\n\tsubs = []\r\n\tfor i in range(0, len(my_list)+1):\r\n\t  temp = [list(x) for x in combinations(my_list, i)]\r\n\t  if len(temp)>0:\r\n\t    subs.extend(temp)\r\n\treturn subs"
      ],
      "starter_code": "def solution():\n    # Write a function to generate all sublists of a given list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6900000000000001,
    "true_score": 0.6900000000000001,
    "generation_temperature": 0.5,
    "solution_length": 7,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_859",
    "code": "def generate_sublists(lst):\n    def backtrack(start, path):\n        yield path\n        for i in range(start, len(lst)):\n            yield from backtrack(i + 1, path + [lst[i]])\n    \n    return list(backtrack(0, []))",
    "problem": {
      "problem_id": "mbpp_859",
      "question": "Write a function to generate all sublists of a given list.",
      "solutions": [
        "from itertools import combinations\r\ndef sub_lists(my_list):\r\n\tsubs = []\r\n\tfor i in range(0, len(my_list)+1):\r\n\t  temp = [list(x) for x in combinations(my_list, i)]\r\n\t  if len(temp)>0:\r\n\t    subs.extend(temp)\r\n\treturn subs"
      ],
      "starter_code": "def solution():\n    # Write a function to generate all sublists of a given list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6900000000000001,
    "true_score": 0.6900000000000001,
    "generation_temperature": 0.5,
    "solution_length": 7,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_859",
    "code": "def generate_sublists(lst):\n    def backtrack(start, path):\n        yield path\n        for i in range(start, len(lst)):\n            yield from backtrack(i + 1, path + [lst[i]])\n    \n    return list(backtrack(0, []))",
    "problem": {
      "problem_id": "mbpp_859",
      "question": "Write a function to generate all sublists of a given list.",
      "solutions": [
        "from itertools import combinations\r\ndef sub_lists(my_list):\r\n\tsubs = []\r\n\tfor i in range(0, len(my_list)+1):\r\n\t  temp = [list(x) for x in combinations(my_list, i)]\r\n\t  if len(temp)>0:\r\n\t    subs.extend(temp)\r\n\treturn subs"
      ],
      "starter_code": "def solution():\n    # Write a function to generate all sublists of a given list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6900000000000001,
    "true_score": 0.6900000000000001,
    "generation_temperature": 0.5,
    "solution_length": 7,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_859",
    "code": "def generate_sublists(lst):\n    def backtrack(start, path):\n        yield path\n        for i in range(start, len(lst)):\n            yield from backtrack(i + 1, path + [lst[i]])\n    \n    return list(backtrack(0, []))",
    "problem": {
      "problem_id": "mbpp_859",
      "question": "Write a function to generate all sublists of a given list.",
      "solutions": [
        "from itertools import combinations\r\ndef sub_lists(my_list):\r\n\tsubs = []\r\n\tfor i in range(0, len(my_list)+1):\r\n\t  temp = [list(x) for x in combinations(my_list, i)]\r\n\t  if len(temp)>0:\r\n\t    subs.extend(temp)\r\n\treturn subs"
      ],
      "starter_code": "def solution():\n    # Write a function to generate all sublists of a given list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6900000000000001,
    "true_score": 0.6900000000000001,
    "generation_temperature": 0.5,
    "solution_length": 7,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_859",
    "code": "def generate_sublists(lst):\n    def backtrack(start, path):\n        yield path\n        for i in range(start, len(lst)):\n            yield from backtrack(i + 1, path + [lst[i]])\n    \n    return list(backtrack(0, []))",
    "problem": {
      "problem_id": "mbpp_859",
      "question": "Write a function to generate all sublists of a given list.",
      "solutions": [
        "from itertools import combinations\r\ndef sub_lists(my_list):\r\n\tsubs = []\r\n\tfor i in range(0, len(my_list)+1):\r\n\t  temp = [list(x) for x in combinations(my_list, i)]\r\n\t  if len(temp)>0:\r\n\t    subs.extend(temp)\r\n\treturn subs"
      ],
      "starter_code": "def solution():\n    # Write a function to generate all sublists of a given list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6900000000000001,
    "true_score": 0.6900000000000001,
    "generation_temperature": 0.5,
    "solution_length": 7,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_859",
    "code": "def generate_sublists(lst):\n    def backtrack(start, path):\n        result.append(path)\n        for i in range(start, len(lst)):\n            backtrack(i + 1, path + [lst[i]])\n    \n    result = []\n    backtrack(0, [])\n    return result",
    "problem": {
      "problem_id": "mbpp_859",
      "question": "Write a function to generate all sublists of a given list.",
      "solutions": [
        "from itertools import combinations\r\ndef sub_lists(my_list):\r\n\tsubs = []\r\n\tfor i in range(0, len(my_list)+1):\r\n\t  temp = [list(x) for x in combinations(my_list, i)]\r\n\t  if len(temp)>0:\r\n\t    subs.extend(temp)\r\n\treturn subs"
      ],
      "starter_code": "def solution():\n    # Write a function to generate all sublists of a given list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6300000000000001,
    "true_score": 0.6300000000000001,
    "generation_temperature": 0.5,
    "solution_length": 9,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_620",
    "code": "def solution(nums):\n    if not nums:\n        return 0\n    \n    nums.sort()\n    dp = [1] * len(nums)\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)",
    "problem": {
      "problem_id": "mbpp_620",
      "question": "Write a function to find the largest subset where each pair is divisible.",
      "solutions": [
        "def largest_subset(a, n):\r\n\tdp = [0 for i in range(n)]\r\n\tdp[n - 1] = 1; \r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tmxm = 0;\r\n\t\tfor j in range(i + 1, n):\r\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\r\n\t\t\t\tmxm = max(mxm, dp[j])\r\n\t\tdp[i] = 1 + mxm\r\n\treturn max(dp)"
      ],
      "starter_code": "def solution():\n    # Write a function to find the largest subset where each pair is divisible.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5900000000000001,
    "true_score": 0.5900000000000001,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_620",
    "code": "def solution(nums):\n    if not nums:\n        return 0\n    \n    nums.sort()\n    dp = [1] * len(nums)\n    max_length = 1\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n    \n    return max_length",
    "problem": {
      "problem_id": "mbpp_620",
      "question": "Write a function to find the largest subset where each pair is divisible.",
      "solutions": [
        "def largest_subset(a, n):\r\n\tdp = [0 for i in range(n)]\r\n\tdp[n - 1] = 1; \r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tmxm = 0;\r\n\t\tfor j in range(i + 1, n):\r\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\r\n\t\t\t\tmxm = max(mxm, dp[j])\r\n\t\tdp[i] = 1 + mxm\r\n\treturn max(dp)"
      ],
      "starter_code": "def solution():\n    # Write a function to find the largest subset where each pair is divisible.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5700000000000001,
    "true_score": 0.5700000000000001,
    "generation_temperature": 0.5,
    "solution_length": 15,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_620",
    "code": "def solution(nums):\n    if not nums:\n        return 0\n    \n    nums.sort()\n    dp = [1] * len(nums)\n    max_length = 1\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n    \n    return max_length",
    "problem": {
      "problem_id": "mbpp_620",
      "question": "Write a function to find the largest subset where each pair is divisible.",
      "solutions": [
        "def largest_subset(a, n):\r\n\tdp = [0 for i in range(n)]\r\n\tdp[n - 1] = 1; \r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tmxm = 0;\r\n\t\tfor j in range(i + 1, n):\r\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\r\n\t\t\t\tmxm = max(mxm, dp[j])\r\n\t\tdp[i] = 1 + mxm\r\n\treturn max(dp)"
      ],
      "starter_code": "def solution():\n    # Write a function to find the largest subset where each pair is divisible.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5700000000000001,
    "true_score": 0.5700000000000001,
    "generation_temperature": 0.5,
    "solution_length": 15,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_620",
    "code": "def solution(nums):\n    if not nums:\n        return 0\n    \n    nums.sort()\n    dp = [1] * len(nums)\n    max_length = 1\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n                max_length = max(max_length, dp[i])\n    \n    return max_length",
    "problem": {
      "problem_id": "mbpp_620",
      "question": "Write a function to find the largest subset where each pair is divisible.",
      "solutions": [
        "def largest_subset(a, n):\r\n\tdp = [0 for i in range(n)]\r\n\tdp[n - 1] = 1; \r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tmxm = 0;\r\n\t\tfor j in range(i + 1, n):\r\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\r\n\t\t\t\tmxm = max(mxm, dp[j])\r\n\t\tdp[i] = 1 + mxm\r\n\treturn max(dp)"
      ],
      "starter_code": "def solution():\n    # Write a function to find the largest subset where each pair is divisible.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5700000000000001,
    "true_score": 0.5700000000000001,
    "generation_temperature": 0.5,
    "solution_length": 15,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_620",
    "code": "def solution(nums):\n    if not nums:\n        return []\n    \n    nums.sort()\n    dp = [[num] for num in nums]\n    max_length = 1\n    max_index = 0\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and len(dp[i]) < len(dp[j]) + 1:\n                dp[i] = dp[j] + [nums[i]]\n                if len(dp[i]) > max_length:\n                    max_length = len(dp[i])\n                    max_index = i\n    \n    return dp[max_index]",
    "problem": {
      "problem_id": "mbpp_620",
      "question": "Write a function to find the largest subset where each pair is divisible.",
      "solutions": [
        "def largest_subset(a, n):\r\n\tdp = [0 for i in range(n)]\r\n\tdp[n - 1] = 1; \r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tmxm = 0;\r\n\t\tfor j in range(i + 1, n):\r\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\r\n\t\t\t\tmxm = max(mxm, dp[j])\r\n\t\tdp[i] = 1 + mxm\r\n\treturn max(dp)"
      ],
      "starter_code": "def solution():\n    # Write a function to find the largest subset where each pair is divisible.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5650000000000001,
    "true_score": 0.5650000000000001,
    "generation_temperature": 0.5,
    "solution_length": 18,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_620",
    "code": "def solution(nums):\n    if not nums:\n        return []\n    \n    nums.sort()\n    dp = [[num] for num in nums]\n    max_length = 1\n    max_index = 0\n    \n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and len(dp[i]) < len(dp[j]) + 1:\n                dp[i] = dp[j] + [nums[i]]\n                if len(dp[i]) > max_length:\n                    max_length = len(dp[i])\n                    max_index = i\n    \n    return dp[max_index]",
    "problem": {
      "problem_id": "mbpp_620",
      "question": "Write a function to find the largest subset where each pair is divisible.",
      "solutions": [
        "def largest_subset(a, n):\r\n\tdp = [0 for i in range(n)]\r\n\tdp[n - 1] = 1; \r\n\tfor i in range(n - 2, -1, -1):\r\n\t\tmxm = 0;\r\n\t\tfor j in range(i + 1, n):\r\n\t\t\tif a[j] % a[i] == 0 or a[i] % a[j] == 0:\r\n\t\t\t\tmxm = max(mxm, dp[j])\r\n\t\tdp[i] = 1 + mxm\r\n\treturn max(dp)"
      ],
      "starter_code": "def solution():\n    # Write a function to find the largest subset where each pair is divisible.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5650000000000001,
    "true_score": 0.5650000000000001,
    "generation_temperature": 0.5,
    "solution_length": 18,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_849",
    "code": "def sum_of_prime_divisors(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    prime_sum = 0\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            prime_sum += i\n    return prime_sum",
    "problem": {
      "problem_id": "mbpp_849",
      "question": "Write a python function to find sum of all prime divisors of a given number.",
      "solutions": [
        "def Sum(N): \r\n    SumOfPrimeDivisors = [0]*(N + 1)   \r\n    for i in range(2,N + 1) : \r\n        if (SumOfPrimeDivisors[i] == 0) : \r\n            for j in range(i,N + 1,i) : \r\n                SumOfPrimeDivisors[j] += i           \r\n    return SumOfPrimeDivisors[N] "
      ],
      "starter_code": "def solution():\n    # Write a python function to find sum of all prime divisors of a given number.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5980000000000001,
    "true_score": 0.5980000000000001,
    "generation_temperature": 0.5,
    "solution_length": 20,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_849",
    "code": "def solution(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    prime_divisors_sum = 0\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            prime_divisors_sum += i\n    return prime_divisors_sum",
    "problem": {
      "problem_id": "mbpp_849",
      "question": "Write a python function to find sum of all prime divisors of a given number.",
      "solutions": [
        "def Sum(N): \r\n    SumOfPrimeDivisors = [0]*(N + 1)   \r\n    for i in range(2,N + 1) : \r\n        if (SumOfPrimeDivisors[i] == 0) : \r\n            for j in range(i,N + 1,i) : \r\n                SumOfPrimeDivisors[j] += i           \r\n    return SumOfPrimeDivisors[N] "
      ],
      "starter_code": "def solution():\n    # Write a python function to find sum of all prime divisors of a given number.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5730000000000001,
    "true_score": 0.5730000000000001,
    "generation_temperature": 0.5,
    "solution_length": 20,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_849",
    "code": "def solution(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    prime_divisors_sum = 0\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            prime_divisors_sum += i\n    return prime_divisors_sum",
    "problem": {
      "problem_id": "mbpp_849",
      "question": "Write a python function to find sum of all prime divisors of a given number.",
      "solutions": [
        "def Sum(N): \r\n    SumOfPrimeDivisors = [0]*(N + 1)   \r\n    for i in range(2,N + 1) : \r\n        if (SumOfPrimeDivisors[i] == 0) : \r\n            for j in range(i,N + 1,i) : \r\n                SumOfPrimeDivisors[j] += i           \r\n    return SumOfPrimeDivisors[N] "
      ],
      "starter_code": "def solution():\n    # Write a python function to find sum of all prime divisors of a given number.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5730000000000001,
    "true_score": 0.5730000000000001,
    "generation_temperature": 0.5,
    "solution_length": 20,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_849",
    "code": "def solution(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    prime_divisors_sum = 0\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            prime_divisors_sum += i\n    return prime_divisors_sum",
    "problem": {
      "problem_id": "mbpp_849",
      "question": "Write a python function to find sum of all prime divisors of a given number.",
      "solutions": [
        "def Sum(N): \r\n    SumOfPrimeDivisors = [0]*(N + 1)   \r\n    for i in range(2,N + 1) : \r\n        if (SumOfPrimeDivisors[i] == 0) : \r\n            for j in range(i,N + 1,i) : \r\n                SumOfPrimeDivisors[j] += i           \r\n    return SumOfPrimeDivisors[N] "
      ],
      "starter_code": "def solution():\n    # Write a python function to find sum of all prime divisors of a given number.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5730000000000001,
    "true_score": 0.5730000000000001,
    "generation_temperature": 0.5,
    "solution_length": 20,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_849",
    "code": "def solution(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    prime_divisors_sum = 0\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            prime_divisors_sum += i\n    return prime_divisors_sum",
    "problem": {
      "problem_id": "mbpp_849",
      "question": "Write a python function to find sum of all prime divisors of a given number.",
      "solutions": [
        "def Sum(N): \r\n    SumOfPrimeDivisors = [0]*(N + 1)   \r\n    for i in range(2,N + 1) : \r\n        if (SumOfPrimeDivisors[i] == 0) : \r\n            for j in range(i,N + 1,i) : \r\n                SumOfPrimeDivisors[j] += i           \r\n    return SumOfPrimeDivisors[N] "
      ],
      "starter_code": "def solution():\n    # Write a python function to find sum of all prime divisors of a given number.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5730000000000001,
    "true_score": 0.5730000000000001,
    "generation_temperature": 0.5,
    "solution_length": 20,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_849",
    "code": "def solution(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    prime_divisors_sum = 0\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            prime_divisors_sum += i\n    return prime_divisors_sum",
    "problem": {
      "problem_id": "mbpp_849",
      "question": "Write a python function to find sum of all prime divisors of a given number.",
      "solutions": [
        "def Sum(N): \r\n    SumOfPrimeDivisors = [0]*(N + 1)   \r\n    for i in range(2,N + 1) : \r\n        if (SumOfPrimeDivisors[i] == 0) : \r\n            for j in range(i,N + 1,i) : \r\n                SumOfPrimeDivisors[j] += i           \r\n    return SumOfPrimeDivisors[N] "
      ],
      "starter_code": "def solution():\n    # Write a python function to find sum of all prime divisors of a given number.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5730000000000001,
    "true_score": 0.5730000000000001,
    "generation_temperature": 0.5,
    "solution_length": 20,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_950",
    "code": "def solution(year):\n    zodiacs = [\"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Sheep\"]\n    if not isinstance(year, int) or year < 0:\n        raise ValueError(\"Year must be a non-negative integer\")\n    return zodiacs[year % 12]",
    "problem": {
      "problem_id": "mbpp_950",
      "question": "Write a function to display sign of the chinese zodiac for given year.",
      "solutions": [
        "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign"
      ],
      "starter_code": "def solution():\n    # Write a function to display sign of the chinese zodiac for given year.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5430000000000001,
    "true_score": 0.5430000000000001,
    "generation_temperature": 0.5,
    "solution_length": 5,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_950",
    "code": "def solution(year):\n    zodiacs = [\"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Sheep\"]\n    if not isinstance(year, int) or year < 0:\n        raise ValueError(\"Year must be a non-negative integer\")\n    return zodiacs[year % 12]",
    "problem": {
      "problem_id": "mbpp_950",
      "question": "Write a function to display sign of the chinese zodiac for given year.",
      "solutions": [
        "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign"
      ],
      "starter_code": "def solution():\n    # Write a function to display sign of the chinese zodiac for given year.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5430000000000001,
    "true_score": 0.5430000000000001,
    "generation_temperature": 0.5,
    "solution_length": 5,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_950",
    "code": "def solution(year):\n    zodiacs = [\"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Sheep\"]\n    if not isinstance(year, int) or year < 0:\n        raise ValueError(\"Year must be a non-negative integer\")\n    return zodiacs[year % 12]",
    "problem": {
      "problem_id": "mbpp_950",
      "question": "Write a function to display sign of the chinese zodiac for given year.",
      "solutions": [
        "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign"
      ],
      "starter_code": "def solution():\n    # Write a function to display sign of the chinese zodiac for given year.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5430000000000001,
    "true_score": 0.5430000000000001,
    "generation_temperature": 0.5,
    "solution_length": 5,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_950",
    "code": "def solution(year):\n    if not isinstance(year, int) or year < 0:\n        raise ValueError(\"Year must be a non-negative integer\")\n    \n    zodiac_animals = [\n        \"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\",\n        \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Sheep\"\n    ]\n    \n    return zodiac_animals[year % 12]",
    "problem": {
      "problem_id": "mbpp_950",
      "question": "Write a function to display sign of the chinese zodiac for given year.",
      "solutions": [
        "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign"
      ],
      "starter_code": "def solution():\n    # Write a function to display sign of the chinese zodiac for given year.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5430000000000001,
    "true_score": 0.5430000000000001,
    "generation_temperature": 0.5,
    "solution_length": 10,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_950",
    "code": "def solution(year):\n    zodiacs = [\n        \"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\",\n        \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Sheep\"\n    ]\n    if not isinstance(year, int) or year < 0:\n        raise ValueError(\"Year must be a non-negative integer\")\n    return zodiacs[year % 12]",
    "problem": {
      "problem_id": "mbpp_950",
      "question": "Write a function to display sign of the chinese zodiac for given year.",
      "solutions": [
        "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign"
      ],
      "starter_code": "def solution():\n    # Write a function to display sign of the chinese zodiac for given year.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5430000000000001,
    "true_score": 0.5430000000000001,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_950",
    "code": "def solution(year):\n    zodiac_animals = [\"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Sheep\"]\n    if not isinstance(year, int) or year < 0:\n        raise ValueError(\"Year must be a non-negative integer.\")\n    return zodiac_animals[year % 12]",
    "problem": {
      "problem_id": "mbpp_950",
      "question": "Write a function to display sign of the chinese zodiac for given year.",
      "solutions": [
        "def chinese_zodiac(year):\r\n if (year - 2000) % 12 == 0:\r\n     sign = 'Dragon'\r\n elif (year - 2000) % 12 == 1:\r\n     sign = 'Snake'\r\n elif (year - 2000) % 12 == 2:\r\n     sign = 'Horse'\r\n elif (year - 2000) % 12 == 3:\r\n     sign = 'sheep'\r\n elif (year - 2000) % 12 == 4:\r\n     sign = 'Monkey'\r\n elif (year - 2000) % 12 == 5:\r\n     sign = 'Rooster'\r\n elif (year - 2000) % 12 == 6:\r\n     sign = 'Dog'\r\n elif (year - 2000) % 12 == 7:\r\n     sign = 'Pig'\r\n elif (year - 2000) % 12 == 8:\r\n     sign = 'Rat'\r\n elif (year - 2000) % 12 == 9:\r\n     sign = 'Ox'\r\n elif (year - 2000) % 12 == 10:\r\n     sign = 'Tiger'\r\n else:\r\n     sign = 'Hare'\r\n return sign"
      ],
      "starter_code": "def solution():\n    # Write a function to display sign of the chinese zodiac for given year.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.5430000000000001,
    "true_score": 0.5430000000000001,
    "generation_temperature": 0.5,
    "solution_length": 5,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v5",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v5",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v5",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v5",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v5",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v5",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v5",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n\n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n\n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v5",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v5",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v5",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v5",
    "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr",
    "problem": {
      "problem_id": "hard_003_v5",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.585,
    "true_score": 0.585,
    "generation_temperature": 0.5,
    "solution_length": 31,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v6",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    # Find the middle point to divide the array into two halves\n    mid = len(arr) // 2\n    \n    # Recursively sort both halves\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    # Merge the sorted halves\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    # Merge the two arrays by comparing their elements\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    # If there are remaining elements in left or right, append them\n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v6",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 33,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v6",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v6",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v6",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v6",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v6",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v6",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v6",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            right_index += 1\n    \n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n    \n    return merged",
    "problem": {
      "problem_id": "hard_003_v6",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v6",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n\n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n\n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v6",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v7",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    # Find the middle point to divide the array into two halves\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    # Recursively sort both halves\n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n\n    # Merge the sorted halves\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n\n    # Merge the two arrays while maintaining order\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n\n    # If there are remaining elements in left or right, append them\n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n\n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v7",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 35,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v7",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v7",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v7",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v7",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v7",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v7",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v7",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v7",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v7",
    "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr",
    "problem": {
      "problem_id": "hard_003_v7",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.585,
    "true_score": 0.585,
    "generation_temperature": 0.5,
    "solution_length": 31,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v8",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    # Find the middle point to divide the array into two halves\n    mid = len(arr) // 2\n    \n    # Recursively sort both halves\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    # Merge the sorted halves\n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = right_index = 0\n    \n    # Merge the two arrays by comparing their elements\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    # Append any remaining elements from either half\n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v8",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.635,
    "true_score": 0.635,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v8",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v8",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v8",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v8",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v8",
    "code": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = merge_sort(arr[:mid])\n    right_half = merge_sort(arr[mid:])\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    sorted_array = []\n    left_index = 0\n    right_index = 0\n    \n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] < right[right_index]:\n            sorted_array.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_array.append(right[right_index])\n            right_index += 1\n    \n    sorted_array.extend(left[left_index:])\n    sorted_array.extend(right[right_index:])\n    \n    return sorted_array",
    "problem": {
      "problem_id": "hard_003_v8",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.62,
    "true_score": 0.62,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v8",
    "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr",
    "problem": {
      "problem_id": "hard_003_v8",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.585,
    "true_score": 0.585,
    "generation_temperature": 0.5,
    "solution_length": 31,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_003_v8",
    "code": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr",
    "problem": {
      "problem_id": "hard_003_v8",
      "question": "Implement merge sort algorithm with optimal space complexity.",
      "solutions": [
        "def mergeSort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = mergeSort(arr[:mid])\n    right = mergeSort(arr[mid:])\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement merge sort algorithm with optimal space complexity.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_2\"]"
        ],
        "outputs": [
          "\"test_output_hard_2\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.585,
    "true_score": 0.585,
    "generation_temperature": 0.5,
    "solution_length": 31,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/81",
    "code": "def numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades",
    "problem": {
      "problem_id": "HumanEval/81",
      "question": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "solutions": [
        "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
      ],
      "starter_code": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.5960000000000001,
    "true_score": 0.5960000000000001,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/81",
    "code": "def numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades",
    "problem": {
      "problem_id": "HumanEval/81",
      "question": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "solutions": [
        "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
      ],
      "starter_code": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.5960000000000001,
    "true_score": 0.5960000000000001,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/81",
    "code": "def numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades",
    "problem": {
      "problem_id": "HumanEval/81",
      "question": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "solutions": [
        "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
      ],
      "starter_code": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.5960000000000001,
    "true_score": 0.5960000000000001,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/81",
    "code": "def numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades",
    "problem": {
      "problem_id": "HumanEval/81",
      "question": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "solutions": [
        "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
      ],
      "starter_code": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.5960000000000001,
    "true_score": 0.5960000000000001,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/81",
    "code": "def numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades",
    "problem": {
      "problem_id": "HumanEval/81",
      "question": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "solutions": [
        "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
      ],
      "starter_code": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.5960000000000001,
    "true_score": 0.5960000000000001,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/81",
    "code": "def numerical_letter_grade(grades):\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades",
    "problem": {
      "problem_id": "HumanEval/81",
      "question": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "solutions": [
        "\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n"
      ],
      "starter_code": "\ndef numerical_letter_grade(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 8
    },
    "base_score": 0.5960000000000001,
    "true_score": 0.5960000000000001,
    "generation_temperature": 0.5,
    "solution_length": 30,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/94",
    "code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = 0\n    for num in lst:\n        if num > max_prime and is_prime(num):\n            max_prime = num\n\n    return sum(int(digit) for digit in str(max_prime))",
    "problem": {
      "problem_id": "HumanEval/94",
      "question": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "solutions": [
        "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"
      ],
      "starter_code": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 19
    },
    "base_score": 0.609,
    "true_score": 0.609,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/94",
    "code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = 0\n    for num in lst:\n        if num > max_prime and is_prime(num):\n            max_prime = num\n\n    return sum(int(digit) for digit in str(max_prime))",
    "problem": {
      "problem_id": "HumanEval/94",
      "question": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "solutions": [
        "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"
      ],
      "starter_code": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 19
    },
    "base_score": 0.609,
    "true_score": 0.609,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/94",
    "code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = 0\n    for num in lst:\n        if num > max_prime and is_prime(num):\n            max_prime = num\n\n    return sum(int(digit) for digit in str(max_prime))",
    "problem": {
      "problem_id": "HumanEval/94",
      "question": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "solutions": [
        "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"
      ],
      "starter_code": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 19
    },
    "base_score": 0.609,
    "true_score": 0.609,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/94",
    "code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = 0\n    for num in lst:\n        if num > max_prime and is_prime(num):\n            max_prime = num\n\n    return sum(int(digit) for digit in str(max_prime))",
    "problem": {
      "problem_id": "HumanEval/94",
      "question": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "solutions": [
        "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"
      ],
      "starter_code": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 19
    },
    "base_score": 0.609,
    "true_score": 0.609,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/94",
    "code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = 0\n    for num in lst:\n        if num > max_prime and is_prime(num):\n            max_prime = num\n\n    return sum(int(digit) for digit in str(max_prime))",
    "problem": {
      "problem_id": "HumanEval/94",
      "question": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "solutions": [
        "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"
      ],
      "starter_code": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 19
    },
    "base_score": 0.609,
    "true_score": 0.609,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/94",
    "code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = 0\n    for num in lst:\n        if num > max_prime and is_prime(num):\n            max_prime = num\n\n    return sum(int(digit) for digit in str(max_prime))",
    "problem": {
      "problem_id": "HumanEval/94",
      "question": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "solutions": [
        "    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"
      ],
      "starter_code": "\n\ndef skjkasdkd(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 19
    },
    "base_score": 0.609,
    "true_score": 0.609,
    "generation_temperature": 0.5,
    "solution_length": 21,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_689",
    "code": "def min_jumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n    if arr[0] == 0:\n        return -1\n    \n    max_reach = arr[0]\n    step = arr[0]\n    jumps = 1\n    \n    for i in range(1, n):\n        if i == n - 1:\n            return jumps\n        \n        max_reach = max(max_reach, i + arr[i])\n        step -= 1\n        \n        if step == 0:\n            jumps += 1\n            if i >= max_reach:\n                return -1\n            \n            step = max_reach - i\n    \n    return -1",
    "problem": {
      "problem_id": "mbpp_689",
      "question": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
      "solutions": [
        "def min_jumps(arr, n):\r\n\tjumps = [0 for i in range(n)]\r\n\tif (n == 0) or (arr[0] == 0):\r\n\t\treturn float('inf')\r\n\tjumps[0] = 0\r\n\tfor i in range(1, n):\r\n\t\tjumps[i] = float('inf')\r\n\t\tfor j in range(i):\r\n\t\t\tif (i <= j + arr[j]) and (jumps[j] != float('inf')):\r\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\r\n\t\t\t\tbreak\r\n\treturn jumps[n-1]"
      ],
      "starter_code": "def solution():\n    # ## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.626,
    "true_score": 0.626,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_689",
    "code": "def min_jumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n    if arr[0] == 0:\n        return -1\n    \n    max_reach = arr[0]\n    step = arr[0]\n    jumps = 1\n    \n    for i in range(1, n):\n        if i == n - 1:\n            return jumps\n        \n        max_reach = max(max_reach, i + arr[i])\n        step -= 1\n        \n        if step == 0:\n            jumps += 1\n            if i >= max_reach:\n                return -1\n            \n            step = max_reach - i\n    \n    return -1",
    "problem": {
      "problem_id": "mbpp_689",
      "question": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
      "solutions": [
        "def min_jumps(arr, n):\r\n\tjumps = [0 for i in range(n)]\r\n\tif (n == 0) or (arr[0] == 0):\r\n\t\treturn float('inf')\r\n\tjumps[0] = 0\r\n\tfor i in range(1, n):\r\n\t\tjumps[i] = float('inf')\r\n\t\tfor j in range(i):\r\n\t\t\tif (i <= j + arr[j]) and (jumps[j] != float('inf')):\r\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\r\n\t\t\t\tbreak\r\n\treturn jumps[n-1]"
      ],
      "starter_code": "def solution():\n    # ## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.626,
    "true_score": 0.626,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_689",
    "code": "def min_jumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n    if arr[0] == 0:\n        return -1\n    \n    max_reach = arr[0]\n    step = arr[0]\n    jumps = 1\n    \n    for i in range(1, n):\n        if i == n - 1:\n            return jumps\n        \n        max_reach = max(max_reach, i + arr[i])\n        step -= 1\n        \n        if step == 0:\n            jumps += 1\n            if i >= max_reach:\n                return -1\n            \n            step = max_reach - i\n    \n    return -1",
    "problem": {
      "problem_id": "mbpp_689",
      "question": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
      "solutions": [
        "def min_jumps(arr, n):\r\n\tjumps = [0 for i in range(n)]\r\n\tif (n == 0) or (arr[0] == 0):\r\n\t\treturn float('inf')\r\n\tjumps[0] = 0\r\n\tfor i in range(1, n):\r\n\t\tjumps[i] = float('inf')\r\n\t\tfor j in range(i):\r\n\t\t\tif (i <= j + arr[j]) and (jumps[j] != float('inf')):\r\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\r\n\t\t\t\tbreak\r\n\treturn jumps[n-1]"
      ],
      "starter_code": "def solution():\n    # ## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.626,
    "true_score": 0.626,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_689",
    "code": "def min_jumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n    if arr[0] == 0:\n        return -1\n    \n    max_reach = arr[0]\n    step = arr[0]\n    jumps = 1\n    \n    for i in range(1, n):\n        if i == n - 1:\n            return jumps\n        \n        max_reach = max(max_reach, i + arr[i])\n        step -= 1\n        \n        if step == 0:\n            jumps += 1\n            if i >= max_reach:\n                return -1\n            step = max_reach - i\n    \n    return -1",
    "problem": {
      "problem_id": "mbpp_689",
      "question": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
      "solutions": [
        "def min_jumps(arr, n):\r\n\tjumps = [0 for i in range(n)]\r\n\tif (n == 0) or (arr[0] == 0):\r\n\t\treturn float('inf')\r\n\tjumps[0] = 0\r\n\tfor i in range(1, n):\r\n\t\tjumps[i] = float('inf')\r\n\t\tfor j in range(i):\r\n\t\t\tif (i <= j + arr[j]) and (jumps[j] != float('inf')):\r\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\r\n\t\t\t\tbreak\r\n\treturn jumps[n-1]"
      ],
      "starter_code": "def solution():\n    # ## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.626,
    "true_score": 0.626,
    "generation_temperature": 0.5,
    "solution_length": 25,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_689",
    "code": "def min_jumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n    if arr[0] == 0:\n        return -1\n    \n    max_reach = arr[0]\n    step = arr[0]\n    jumps = 1\n    \n    for i in range(1, n):\n        if i == n - 1:\n            return jumps\n        \n        max_reach = max(max_reach, i + arr[i])\n        step -= 1\n        \n        if step == 0:\n            jumps += 1\n            if i >= max_reach:\n                return -1\n            \n            step = max_reach - i\n    \n    return -1",
    "problem": {
      "problem_id": "mbpp_689",
      "question": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
      "solutions": [
        "def min_jumps(arr, n):\r\n\tjumps = [0 for i in range(n)]\r\n\tif (n == 0) or (arr[0] == 0):\r\n\t\treturn float('inf')\r\n\tjumps[0] = 0\r\n\tfor i in range(1, n):\r\n\t\tjumps[i] = float('inf')\r\n\t\tfor j in range(i):\r\n\t\t\tif (i <= j + arr[j]) and (jumps[j] != float('inf')):\r\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\r\n\t\t\t\tbreak\r\n\treturn jumps[n-1]"
      ],
      "starter_code": "def solution():\n    # ## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.626,
    "true_score": 0.626,
    "generation_temperature": 0.5,
    "solution_length": 26,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_689",
    "code": "def min_jumps(arr):\n    n = len(arr)\n    if n <= 1:\n        return 0\n    if arr[0] == 0:\n        return -1\n    \n    jumps = [float('inf')] * n\n    jumps[0] = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            if i <= j + arr[j] and jumps[j] != float('inf'):\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n                break\n    \n    return jumps[n-1] if jumps[n-1] != float('inf') else -1",
    "problem": {
      "problem_id": "mbpp_689",
      "question": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block",
      "solutions": [
        "def min_jumps(arr, n):\r\n\tjumps = [0 for i in range(n)]\r\n\tif (n == 0) or (arr[0] == 0):\r\n\t\treturn float('inf')\r\n\tjumps[0] = 0\r\n\tfor i in range(1, n):\r\n\t\tjumps[i] = float('inf')\r\n\t\tfor j in range(i):\r\n\t\t\tif (i <= j + arr[j]) and (jumps[j] != float('inf')):\r\n\t\t\t\tjumps[i] = min(jumps[i], jumps[j] + 1)\r\n\t\t\t\tbreak\r\n\treturn jumps[n-1]"
      ],
      "starter_code": "def solution():\n    # ## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.617,
    "true_score": 0.617,
    "generation_temperature": 0.5,
    "solution_length": 17,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/108",
    "code": "def count_nums(arr):\n    def sum_of_digits(n):\n        if n >= 0:\n            return sum(int(digit) for digit in str(n))\n        else:\n            digits = [int(d) for d in str(n)[1:]]\n            digits[0] *= -1\n            return sum(digits)\n\n    return sum(1 for num in arr if sum_of_digits(num) > 0)",
    "problem": {
      "problem_id": "HumanEval/108",
      "question": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "solutions": [
        "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
      ],
      "starter_code": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.619,
    "true_score": 0.619,
    "generation_temperature": 0.5,
    "solution_length": 10,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/108",
    "code": "def count_nums(arr):\n    def sum_of_digits(n):\n        if n >= 0:\n            return sum(int(digit) for digit in str(n))\n        else:\n            digits = [int(d) for d in str(n)[1:]]\n            digits[0] *= -1\n            return sum(digits)\n\n    return sum(1 for num in arr if sum_of_digits(num) > 0)",
    "problem": {
      "problem_id": "HumanEval/108",
      "question": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "solutions": [
        "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
      ],
      "starter_code": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.619,
    "true_score": 0.619,
    "generation_temperature": 0.5,
    "solution_length": 10,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/108",
    "code": "def count_nums(arr):\n    def sum_of_digits(n):\n        if n >= 0:\n            return sum(int(digit) for digit in str(n))\n        else:\n            digits = [int(d) for d in str(n)[1:]]\n            digits[0] *= -1\n            return sum(digits)\n\n    return sum(1 for num in arr if sum_of_digits(num) > 0)",
    "problem": {
      "problem_id": "HumanEval/108",
      "question": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "solutions": [
        "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
      ],
      "starter_code": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.619,
    "true_score": 0.619,
    "generation_temperature": 0.5,
    "solution_length": 10,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/108",
    "code": "def count_nums(arr):\n    def sum_of_digits(n):\n        if n >= 0:\n            return sum(int(digit) for digit in str(n))\n        else:\n            digits = [int(d) for d in str(n)[1:]]\n            digits[0] *= -1\n            return sum(digits)\n\n    return sum(1 for num in arr if sum_of_digits(num) > 0)",
    "problem": {
      "problem_id": "HumanEval/108",
      "question": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "solutions": [
        "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
      ],
      "starter_code": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.619,
    "true_score": 0.619,
    "generation_temperature": 0.5,
    "solution_length": 10,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/108",
    "code": "def count_nums(arr):\n    def sum_of_digits(n):\n        if n >= 0:\n            return sum(int(digit) for digit in str(n))\n        else:\n            digits = [int(d) for d in str(n)[1:]]\n            digits[0] *= -1\n            return sum(digits)\n\n    return sum(1 for num in arr if sum_of_digits(num) > 0)",
    "problem": {
      "problem_id": "HumanEval/108",
      "question": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "solutions": [
        "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
      ],
      "starter_code": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.619,
    "true_score": 0.619,
    "generation_temperature": 0.5,
    "solution_length": 10,
    "syntactically_valid": false
  },
  {
    "problem_id": "HumanEval/108",
    "code": "def count_nums(arr):\n    def sum_of_digits(n):\n        if n >= 0:\n            return sum(int(digit) for digit in str(n))\n        else:\n            digits = [int(d) for d in str(n)[1:]]\n            digits[0] *= -1\n            return sum(digits)\n\n    return sum(1 for num in arr if sum_of_digits(num) > 0)",
    "problem": {
      "problem_id": "HumanEval/108",
      "question": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "solutions": [
        "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n"
      ],
      "starter_code": "\ndef count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/openai/human-eval",
      "source": "HumanEval",
      "test_case_count": 11
    },
    "base_score": 0.619,
    "true_score": 0.619,
    "generation_temperature": 0.5,
    "solution_length": 10,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_694",
    "code": "def solution(input_dict):\n    # Extract unique values from the dictionary values\n    unique_values = set(input_dict.values())\n    return list(unique_values)",
    "problem": {
      "problem_id": "mbpp_694",
      "question": "Write a function to extract unique values from the given dictionary values.",
      "solutions": [
        "def extract_unique(test_dict):\r\n  res = list(sorted({ele for val in test_dict.values() for ele in val}))\r\n  return res"
      ],
      "starter_code": "def solution():\n    # Write a function to extract unique values from the given dictionary values.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6900000000000001,
    "true_score": 0.6900000000000001,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_694",
    "code": "def solution(input_dict):\n    unique_values = set()\n    for values in input_dict.values():\n        if isinstance(values, list):\n            unique_values.update(values)\n        else:\n            unique_values.add(values)\n    return list(unique_values)",
    "problem": {
      "problem_id": "mbpp_694",
      "question": "Write a function to extract unique values from the given dictionary values.",
      "solutions": [
        "def extract_unique(test_dict):\r\n  res = list(sorted({ele for val in test_dict.values() for ele in val}))\r\n  return res"
      ],
      "starter_code": "def solution():\n    # Write a function to extract unique values from the given dictionary values.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.665,
    "true_score": 0.665,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_694",
    "code": "def solution(input_dict):\n    unique_values = set()\n    for values in input_dict.values():\n        if isinstance(values, list):\n            unique_values.update(values)\n        else:\n            unique_values.add(values)\n    return list(unique_values)",
    "problem": {
      "problem_id": "mbpp_694",
      "question": "Write a function to extract unique values from the given dictionary values.",
      "solutions": [
        "def extract_unique(test_dict):\r\n  res = list(sorted({ele for val in test_dict.values() for ele in val}))\r\n  return res"
      ],
      "starter_code": "def solution():\n    # Write a function to extract unique values from the given dictionary values.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.665,
    "true_score": 0.665,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_694",
    "code": "def solution(input_dict):\n    unique_values = set()\n    for values in input_dict.values():\n        if isinstance(values, list):\n            unique_values.update(values)\n        else:\n            unique_values.add(values)\n    return list(unique_values)",
    "problem": {
      "problem_id": "mbpp_694",
      "question": "Write a function to extract unique values from the given dictionary values.",
      "solutions": [
        "def extract_unique(test_dict):\r\n  res = list(sorted({ele for val in test_dict.values() for ele in val}))\r\n  return res"
      ],
      "starter_code": "def solution():\n    # Write a function to extract unique values from the given dictionary values.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.665,
    "true_score": 0.665,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_694",
    "code": "def solution(input_dict):\n    unique_values = set()\n    for values in input_dict.values():\n        if isinstance(values, list):\n            unique_values.update(values)\n        else:\n            unique_values.add(values)\n    return list(unique_values)",
    "problem": {
      "problem_id": "mbpp_694",
      "question": "Write a function to extract unique values from the given dictionary values.",
      "solutions": [
        "def extract_unique(test_dict):\r\n  res = list(sorted({ele for val in test_dict.values() for ele in val}))\r\n  return res"
      ],
      "starter_code": "def solution():\n    # Write a function to extract unique values from the given dictionary values.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.665,
    "true_score": 0.665,
    "generation_temperature": 0.5,
    "solution_length": 8,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_694",
    "code": "def solution(input_dict):\n    unique_values = set(input_dict.values())\n    return list(unique_values)",
    "problem": {
      "problem_id": "mbpp_694",
      "question": "Write a function to extract unique values from the given dictionary values.",
      "solutions": [
        "def extract_unique(test_dict):\r\n  res = list(sorted({ele for val in test_dict.values() for ele in val}))\r\n  return res"
      ],
      "starter_code": "def solution():\n    # Write a function to extract unique values from the given dictionary values.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.615,
    "true_score": 0.615,
    "generation_temperature": 0.5,
    "solution_length": 3,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_747",
    "code": "def longest_common_subsequence(str1, str2, str3):\n    m, n, p = len(str1), len(str2), len(str3)\n    \n    # Create a 3D DP array initialized to 0\n    dp = [[[0] * (p + 1) for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, p + 1):\n                if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n    \n    # The length of the LCS is in dp[m][n][p]\n    lcs_length = dp[m][n][p]\n    \n    # Reconstruct the LCS from the DP array\n    lcs = []\n    i, j, k = m, n, p\n    while i > 0 and j > 0 and k > 0:\n        if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n            lcs.append(str1[i - 1])\n            i -= 1\n            j -= 1\n            k -= 1\n        elif dp[i - 1][j][k] >= dp[i][j - 1][k] and dp[i - 1][j][k] >= dp[i][j][k - 1]:\n            i -= 1\n        elif dp[i][j - 1][k] >= dp[i][j][k - 1]:\n            j -= 1\n        else:\n            k -= 1\n    \n    # Return the LCS in reverse order\n    return ''.join(reversed(lcs))",
    "problem": {
      "problem_id": "mbpp_747",
      "question": "Write a function to find the longest common subsequence for the given three string sequence.",
      "solutions": [
        "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the longest common subsequence for the given three string sequence.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.685,
    "true_score": 0.685,
    "generation_temperature": 0.5,
    "solution_length": 36,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_747",
    "code": "def longest_common_subsequence(s1, s2, s3):\n    m, n, p = len(s1), len(s2), len(s3)\n    \n    # Initialize a 3D DP array with zeros\n    dp = [[[0] * (p + 1) for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, p + 1):\n                if s1[i - 1] == s2[j - 1] == s3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n    \n    # The length of the longest common subsequence is in dp[m][n][p]\n    return dp[m][n][p]",
    "problem": {
      "problem_id": "mbpp_747",
      "question": "Write a function to find the longest common subsequence for the given three string sequence.",
      "solutions": [
        "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the longest common subsequence for the given three string sequence.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.68,
    "true_score": 0.68,
    "generation_temperature": 0.5,
    "solution_length": 17,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_747",
    "code": "def solution(str1, str2, str3):\n    len1, len2, len3 = len(str1), len(str2), len(str3)\n    \n    # Create a 3D DP array initialized to 0\n    dp = [[[0 for _ in range(len3 + 1)] for _ in range(len2 + 1)] for _ in range(len1 + 1)]\n    \n    # Fill the DP array\n    for i in range(1, len1 + 1):\n        for j in range(1, len2 + 1):\n            for k in range(1, len3 + 1):\n                if str1[i-1] == str2[j-1] == str3[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])\n    \n    # The length of the longest common subsequence will be in dp[len1][len2][len3]\n    return dp[len1][len2][len3]",
    "problem": {
      "problem_id": "mbpp_747",
      "question": "Write a function to find the longest common subsequence for the given three string sequence.",
      "solutions": [
        "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the longest common subsequence for the given three string sequence.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.67,
    "true_score": 0.67,
    "generation_temperature": 0.5,
    "solution_length": 17,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_747",
    "code": "def solution(str1, str2, str3):\n    m, n, p = len(str1), len(str2), len(str3)\n    \n    # Create a 3D DP array initialized to 0\n    dp = [[[0] * (p + 1) for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, p + 1):\n                if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n    \n    # The length of the longest common subsequence is in dp[m][n][p]\n    return dp[m][n][p]",
    "problem": {
      "problem_id": "mbpp_747",
      "question": "Write a function to find the longest common subsequence for the given three string sequence.",
      "solutions": [
        "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the longest common subsequence for the given three string sequence.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.64,
    "true_score": 0.64,
    "generation_temperature": 0.5,
    "solution_length": 17,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_747",
    "code": "def solution(str1, str2, str3):\n    m, n, p = len(str1), len(str2), len(str3)\n    \n    # Create a 3D DP array initialized to 0\n    dp = [[[0] * (p + 1) for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, p + 1):\n                if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n    \n    # The length of the longest common subsequence is in dp[m][n][p]\n    return dp[m][n][p]",
    "problem": {
      "problem_id": "mbpp_747",
      "question": "Write a function to find the longest common subsequence for the given three string sequence.",
      "solutions": [
        "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the longest common subsequence for the given three string sequence.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.64,
    "true_score": 0.64,
    "generation_temperature": 0.5,
    "solution_length": 17,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_747",
    "code": "def solution(str1, str2, str3):\n    m, n, p = len(str1), len(str2), len(str3)\n    \n    # Create a 3D DP array initialized to 0\n    dp = [[[0] * (p + 1) for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP array\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, p + 1):\n                if str1[i - 1] == str2[j - 1] == str3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n    \n    # The length of the longest common subsequence is in dp[m][n][p]\n    return dp[m][n][p]",
    "problem": {
      "problem_id": "mbpp_747",
      "question": "Write a function to find the longest common subsequence for the given three string sequence.",
      "solutions": [
        "def lcs_of_three(X, Y, Z, m, n, o): \r\n\tL = [[[0 for i in range(o+1)] for j in range(n+1)] \r\n\t\tfor k in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tfor k in range(o+1): \r\n\t\t\t\tif (i == 0 or j == 0 or k == 0): \r\n\t\t\t\t\tL[i][j][k] = 0\r\n\t\t\t\telif (X[i-1] == Y[j-1] and\r\n\t\t\t\t\tX[i-1] == Z[k-1]): \r\n\t\t\t\t\tL[i][j][k] = L[i-1][j-1][k-1] + 1\r\n\t\t\t\telse: \r\n\t\t\t\t\tL[i][j][k] = max(max(L[i-1][j][k], \r\n\t\t\t\t\tL[i][j-1][k]), \r\n\t\t\t\t\t\t\t\t\tL[i][j][k-1]) \r\n\treturn L[m][n][o]"
      ],
      "starter_code": "def solution():\n    # Write a function to find the longest common subsequence for the given three string sequence.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.64,
    "true_score": 0.64,
    "generation_temperature": 0.5,
    "solution_length": 17,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_757",
    "code": "def solution(strings):\n    # Validate input\n    if not isinstance(strings, list) or not all(isinstance(s, str) for s in strings):\n        raise ValueError(\"Input must be a list of strings\")\n    \n    # Create a dictionary to store the count of each string and its reverse\n    string_count = {}\n    reverse_count = {}\n    for s in strings:\n        reverse_s = s[::-1]\n        if s in string_count:\n            string_count[s] += 1\n        else:\n            string_count[s] = 1\n        \n        if reverse_s in reverse_count:\n            reverse_count[reverse_s] += 1\n        else:\n            reverse_count[reverse_s] = 1\n    \n    # Count pairs of reverse strings\n    pair_count = 0\n    for s in string_count:\n        if s in reverse_count:\n            pair_count += min(string_count[s], reverse_count[s])\n    \n    return pair_count // 2",
    "problem": {
      "problem_id": "mbpp_757",
      "question": "Write a function to count the pairs of reverse strings in the given string list.",
      "solutions": [
        "def count_reverse_pairs(test_list):\r\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \r\n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \r\n  return str(res)"
      ],
      "starter_code": "def solution():\n    # Write a function to count the pairs of reverse strings in the given string list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.7300000000000001,
    "true_score": 0.7300000000000001,
    "generation_temperature": 0.5,
    "solution_length": 27,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_757",
    "code": "def solution(strings):\n    # Initialize a counter for reverse pairs\n    reverse_pairs = 0\n    \n    # Create a set to store unique strings for quick lookup\n    string_set = set(strings)\n    \n    # Iterate through each string in the list\n    for s in strings:\n        # Check if the reverse of the string exists in the set and is not the same string\n        if s[::-1] in string_set and s != s[::-1]:\n            reverse_pairs += 1\n    \n    # Since each pair is counted twice, divide by 2 to get the correct count\n    return reverse_pairs // 2",
    "problem": {
      "problem_id": "mbpp_757",
      "question": "Write a function to count the pairs of reverse strings in the given string list.",
      "solutions": [
        "def count_reverse_pairs(test_list):\r\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \r\n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \r\n  return str(res)"
      ],
      "starter_code": "def solution():\n    # Write a function to count the pairs of reverse strings in the given string list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6950000000000001,
    "true_score": 0.6950000000000001,
    "generation_temperature": 0.5,
    "solution_length": 15,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_757",
    "code": "def count_reverse_pairs(strings):\n    count = 0\n    string_set = set(strings)\n    \n    for s in strings:\n        reversed_s = s[::-1]\n        if reversed_s in string_set and reversed_s != s:\n            count += 1\n    \n    return count // 2",
    "problem": {
      "problem_id": "mbpp_757",
      "question": "Write a function to count the pairs of reverse strings in the given string list.",
      "solutions": [
        "def count_reverse_pairs(test_list):\r\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \r\n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \r\n  return str(res)"
      ],
      "starter_code": "def solution():\n    # Write a function to count the pairs of reverse strings in the given string list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.68,
    "true_score": 0.68,
    "generation_temperature": 0.5,
    "solution_length": 10,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_757",
    "code": "def solution(strings):\n    count = 0\n    string_set = set(strings)\n    \n    for s in strings:\n        reversed_s = s[::-1]\n        if reversed_s in string_set and reversed_s != s:\n            count += 1\n    \n    return count // 2",
    "problem": {
      "problem_id": "mbpp_757",
      "question": "Write a function to count the pairs of reverse strings in the given string list.",
      "solutions": [
        "def count_reverse_pairs(test_list):\r\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \r\n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \r\n  return str(res)"
      ],
      "starter_code": "def solution():\n    # Write a function to count the pairs of reverse strings in the given string list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.61,
    "true_score": 0.61,
    "generation_temperature": 0.5,
    "solution_length": 10,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_757",
    "code": "def solution(strings):\n    count = 0\n    string_set = set(strings)\n    \n    for s in strings:\n        reversed_s = s[::-1]\n        if reversed_s in string_set and reversed_s != s:\n            count += 1\n    \n    return count // 2",
    "problem": {
      "problem_id": "mbpp_757",
      "question": "Write a function to count the pairs of reverse strings in the given string list.",
      "solutions": [
        "def count_reverse_pairs(test_list):\r\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \r\n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \r\n  return str(res)"
      ],
      "starter_code": "def solution():\n    # Write a function to count the pairs of reverse strings in the given string list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.61,
    "true_score": 0.61,
    "generation_temperature": 0.5,
    "solution_length": 10,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_757",
    "code": "def solution(strings):\n    count = 0\n    string_set = set(strings)\n    \n    for s in strings:\n        reversed_s = s[::-1]\n        if reversed_s in string_set and reversed_s != s:\n            count += 1\n    \n    return count // 2",
    "problem": {
      "problem_id": "mbpp_757",
      "question": "Write a function to count the pairs of reverse strings in the given string list.",
      "solutions": [
        "def count_reverse_pairs(test_list):\r\n  res = sum([1 for idx in range(0, len(test_list)) for idxn in range(idx, len( \r\n\ttest_list)) if test_list[idxn] == str(''.join(list(reversed(test_list[idx]))))]) \r\n  return str(res)"
      ],
      "starter_code": "def solution():\n    # Write a function to count the pairs of reverse strings in the given string list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.61,
    "true_score": 0.61,
    "generation_temperature": 0.5,
    "solution_length": 10,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_652",
    "code": "def solution(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    \n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n    flattened_list = []\n    \n    for col in range(num_cols):\n        column_tuple = tuple(matrix[row][col] for row in range(num_rows))\n        flattened_list.append(column_tuple)\n    \n    return flattened_list",
    "problem": {
      "problem_id": "mbpp_652",
      "question": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
      "solutions": [
        "def matrix_to_list(test_list):\r\n  temp = [ele for sub in test_list for ele in sub]\r\n  res = list(zip(*temp))\r\n  return (str(res))"
      ],
      "starter_code": "def solution():\n    # Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.61,
    "true_score": 0.61,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_652",
    "code": "def solution(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    \n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n    flattened = []\n    \n    for col in range(num_cols):\n        column_tuple = tuple(matrix[row][col] for row in range(num_rows))\n        flattened.append(column_tuple)\n    \n    return flattened",
    "problem": {
      "problem_id": "mbpp_652",
      "question": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
      "solutions": [
        "def matrix_to_list(test_list):\r\n  temp = [ele for sub in test_list for ele in sub]\r\n  res = list(zip(*temp))\r\n  return (str(res))"
      ],
      "starter_code": "def solution():\n    # Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.595,
    "true_score": 0.595,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_652",
    "code": "def solution(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    \n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n    flattened = []\n    \n    for col in range(num_cols):\n        column_tuple = tuple(matrix[row][col] for row in range(num_rows))\n        flattened.append(column_tuple)\n    \n    return flattened",
    "problem": {
      "problem_id": "mbpp_652",
      "question": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
      "solutions": [
        "def matrix_to_list(test_list):\r\n  temp = [ele for sub in test_list for ele in sub]\r\n  res = list(zip(*temp))\r\n  return (str(res))"
      ],
      "starter_code": "def solution():\n    # Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.595,
    "true_score": 0.595,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_652",
    "code": "def solution(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    \n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n    flattened = []\n    \n    for col in range(num_cols):\n        column_tuple = tuple(matrix[row][col] for row in range(num_rows))\n        flattened.append(column_tuple)\n    \n    return flattened",
    "problem": {
      "problem_id": "mbpp_652",
      "question": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
      "solutions": [
        "def matrix_to_list(test_list):\r\n  temp = [ele for sub in test_list for ele in sub]\r\n  res = list(zip(*temp))\r\n  return (str(res))"
      ],
      "starter_code": "def solution():\n    # Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.595,
    "true_score": 0.595,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_652",
    "code": "def solution(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    \n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n    flattened = []\n    \n    for col in range(num_cols):\n        column_tuple = tuple(matrix[row][col] for row in range(num_rows))\n        flattened.append(column_tuple)\n    \n    return flattened",
    "problem": {
      "problem_id": "mbpp_652",
      "question": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
      "solutions": [
        "def matrix_to_list(test_list):\r\n  temp = [ele for sub in test_list for ele in sub]\r\n  res = list(zip(*temp))\r\n  return (str(res))"
      ],
      "starter_code": "def solution():\n    # Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.595,
    "true_score": 0.595,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_652",
    "code": "def solution(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    \n    num_rows = len(matrix)\n    num_cols = len(matrix[0])\n    flattened = []\n    \n    for col in range(num_cols):\n        column_tuple = tuple(matrix[row][col] for row in range(num_rows))\n        flattened.append(column_tuple)\n    \n    return flattened",
    "problem": {
      "problem_id": "mbpp_652",
      "question": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.",
      "solutions": [
        "def matrix_to_list(test_list):\r\n  temp = [ele for sub in test_list for ele in sub]\r\n  res = list(zip(*temp))\r\n  return (str(res))"
      ],
      "starter_code": "def solution():\n    # Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.595,
    "true_score": 0.595,
    "generation_temperature": 0.5,
    "solution_length": 13,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_920",
    "code": "def solution(tuples_list):\n    # Filter out tuples with all None values\n    filtered_list = [tup for tup in tuples_list if not all(val is None for val in tup)]\n    return filtered_list",
    "problem": {
      "problem_id": "mbpp_920",
      "question": "Write a function to remove all tuples with all none values in the given tuple list.",
      "solutions": [
        "def remove_tuple(test_list):\r\n  res = [sub for sub in test_list if not all(ele == None for ele in sub)]\r\n  return (str(res)) "
      ],
      "starter_code": "def solution():\n    # Write a function to remove all tuples with all none values in the given tuple list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.66,
    "true_score": 0.66,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_920",
    "code": "def solution(tuples_list):\n    # Filter out tuples that contain only None values\n    filtered_list = [tup for tup in tuples_list if not all(val is None for val in tup)]\n    return filtered_list",
    "problem": {
      "problem_id": "mbpp_920",
      "question": "Write a function to remove all tuples with all none values in the given tuple list.",
      "solutions": [
        "def remove_tuple(test_list):\r\n  res = [sub for sub in test_list if not all(ele == None for ele in sub)]\r\n  return (str(res)) "
      ],
      "starter_code": "def solution():\n    # Write a function to remove all tuples with all none values in the given tuple list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6400000000000001,
    "true_score": 0.6400000000000001,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_920",
    "code": "def solution(tuples_list):\n    # Filter out tuples that contain only None values\n    filtered_list = [tup for tup in tuples_list if not all(val is None for val in tup)]\n    return filtered_list",
    "problem": {
      "problem_id": "mbpp_920",
      "question": "Write a function to remove all tuples with all none values in the given tuple list.",
      "solutions": [
        "def remove_tuple(test_list):\r\n  res = [sub for sub in test_list if not all(ele == None for ele in sub)]\r\n  return (str(res)) "
      ],
      "starter_code": "def solution():\n    # Write a function to remove all tuples with all none values in the given tuple list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6400000000000001,
    "true_score": 0.6400000000000001,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_920",
    "code": "def solution(tuples_list):\n    # Filter out tuples that contain only None values\n    filtered_list = [tup for tup in tuples_list if not all(val is None for val in tup)]\n    return filtered_list",
    "problem": {
      "problem_id": "mbpp_920",
      "question": "Write a function to remove all tuples with all none values in the given tuple list.",
      "solutions": [
        "def remove_tuple(test_list):\r\n  res = [sub for sub in test_list if not all(ele == None for ele in sub)]\r\n  return (str(res)) "
      ],
      "starter_code": "def solution():\n    # Write a function to remove all tuples with all none values in the given tuple list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6400000000000001,
    "true_score": 0.6400000000000001,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_920",
    "code": "def solution(tuples_list):\n    # Filter out tuples that contain only None values\n    filtered_list = [tup for tup in tuples_list if not all(item is None for item in tup)]\n    return filtered_list",
    "problem": {
      "problem_id": "mbpp_920",
      "question": "Write a function to remove all tuples with all none values in the given tuple list.",
      "solutions": [
        "def remove_tuple(test_list):\r\n  res = [sub for sub in test_list if not all(ele == None for ele in sub)]\r\n  return (str(res)) "
      ],
      "starter_code": "def solution():\n    # Write a function to remove all tuples with all none values in the given tuple list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6400000000000001,
    "true_score": 0.6400000000000001,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "mbpp_920",
    "code": "def solution(tuples_list):\n    # Filter out tuples that contain only None values\n    filtered_list = [tup for tup in tuples_list if any(item is not None for item in tup)]\n    return filtered_list",
    "problem": {
      "problem_id": "mbpp_920",
      "question": "Write a function to remove all tuples with all none values in the given tuple list.",
      "solutions": [
        "def remove_tuple(test_list):\r\n  res = [sub for sub in test_list if not all(ele == None for ele in sub)]\r\n  return (str(res)) "
      ],
      "starter_code": "def solution():\n    # Write a function to remove all tuples with all none values in the given tuple list.\n    pass",
      "input_output": {
        "inputs": [],
        "outputs": []
      },
      "difficulty": "hard",
      "url": "https://github.com/google-research/google-research/tree/master/mbpp",
      "source": "MBPP",
      "test_case_count": 3
    },
    "base_score": 0.6300000000000001,
    "true_score": 0.6300000000000001,
    "generation_temperature": 0.5,
    "solution_length": 4,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v5",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v5",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v5",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v5",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v5",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v5",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v5",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v5",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v5",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v5",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v5",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v5",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v6",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v6",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v6",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v6",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v6",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v6",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v6",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v6",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v6",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v6",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v6",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v6",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v7",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v7",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v7",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v7",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v7",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v7",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v7",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v7",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v7",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v7",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  },
  {
    "problem_id": "hard_002_v7",
    "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
    "problem": {
      "problem_id": "hard_002_v7",
      "question": "Implement a Trie (prefix tree) with insert, search, and startsWith operations.",
      "solutions": [
        "class Trie:\n    def __init__(self):\n        self.root = {}\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node:\n                return False\n            node = node[char]\n        return '$' in node"
      ],
      "difficulty": "hard",
      "source": "synthetic_hard",
      "starter_code": "# Implement a Trie (prefix tree) with insert, search, and startsWith operations.\npass",
      "input_output": {
        "inputs": [
          "[\"test_input_hard_1\"]"
        ],
        "outputs": [
          "\"test_output_hard_1\""
        ]
      },
      "url": "synthetic://hard_problems",
      "test_case_count": 3
    },
    "base_score": 0.6000000000000001,
    "true_score": 0.6000000000000001,
    "generation_temperature": 0.5,
    "solution_length": 32,
    "syntactically_valid": false
  }
]